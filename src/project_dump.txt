
===== ./api/handlers.rs =====
//! HTTP request handlers with OpenAPI documentation.

use std::sync::Arc;

use axum::{
    Json,
    extract::{Path, Query, State},
    http::{HeaderMap, StatusCode},
    response::IntoResponse,
};
use tracing::{error, info};
use utoipa::OpenApi;

use crate::app::AppState;
use crate::domain::{
    AppError, BlockchainError, DatabaseError, ErrorDetail, ErrorResponse, ExternalServiceError,
    HealthResponse, HealthStatus, HeliusTransaction, PaginatedResponse, PaginationParams,
    RateLimitResponse, SubmitTransferRequest, TransferRequest,
};

/// OpenAPI documentation structure
#[derive(OpenApi)]
#[openapi(
    info(
        title = "Solana Compliance Relayer API",
        version = "0.3.0",
        description = "API for submitting and tracking compliant Solana transfers",
        contact(
            name = "API Support",
            email = "support@example.com"
        ),
        license(
            name = "MIT"
        )
    ),
    paths(
        submit_transfer_handler,
        list_transfer_requests_handler,
        get_transfer_request_handler,
        retry_blockchain_handler,
        health_check_handler,
        liveness_handler,
        readiness_handler,
    ),
    components(
        schemas(
            TransferRequest,
            SubmitTransferRequest,
            crate::domain::ComplianceStatus,
            crate::domain::BlockchainStatus,
            PaginationParams,
            PaginatedResponse<TransferRequest>,
            HealthResponse,
            HealthStatus,
            ErrorResponse,
            ErrorDetail,
            RateLimitResponse,
        )
    ),
    tags(
        (name = "transfers", description = "Transfer request management endpoints"),
        (name = "health", description = "Health check endpoints")
    )
)]
pub struct ApiDoc;

/// Submit a new transfer request
///
/// Accepts a transfer for processing. The request is validated, screened
/// for compliance, and queued for blockchain submission by background workers.
///
/// **Response indicates acceptance, not blockchain confirmation.**
/// Poll `GET /transfer-requests/{id}` to track `blockchain_status` progression:
/// - `pending_submission` → queued for worker
/// - `processing` → worker is submitting
/// - `submitted` → on-chain, awaiting confirmation
/// - `confirmed` → finalized on blockchain
#[utoipa::path(
    post,
    path = "/transfer-requests",
    tag = "transfers",
    request_body = SubmitTransferRequest,
    responses(
        (status = 200, description = "Transfer accepted for processing (blockchain_status will be 'pending_submission')", body = TransferRequest),
        (status = 400, description = "Validation error - invalid request format", body = ErrorResponse),
        (status = 429, description = "Rate limit exceeded", body = RateLimitResponse),
        (status = 500, description = "Internal server error", body = ErrorResponse),
        (status = 503, description = "Service unavailable", body = ErrorResponse)
    )
)]
pub async fn submit_transfer_handler(
    State(state): State<Arc<AppState>>,
    Json(payload): Json<SubmitTransferRequest>,
) -> Result<Json<TransferRequest>, AppError> {
    let request = state.service.submit_transfer(&payload).await?;
    Ok(Json(request))
}

/// List transfer requests with pagination
#[utoipa::path(
    get,
    path = "/transfer-requests",
    tag = "transfers",
    params(
        ("limit" = Option<i64>, Query, description = "Maximum number of requests to return (1-100, default: 20)"),
        ("cursor" = Option<String>, Query, description = "Cursor for pagination (request ID to start after)")
    ),
    responses(
        (status = 200, description = "List of transfer requests", body = PaginatedResponse<TransferRequest>),
        (status = 400, description = "Invalid pagination parameters", body = ErrorResponse),
        (status = 429, description = "Rate limit exceeded", body = RateLimitResponse),
        (status = 500, description = "Internal server error", body = ErrorResponse)
    )
)]
pub async fn list_transfer_requests_handler(
    State(state): State<Arc<AppState>>,
    Query(params): Query<PaginationParams>,
) -> Result<Json<PaginatedResponse<TransferRequest>>, AppError> {
    // Validate limit
    let limit = params.limit.clamp(1, 100);
    let requests = state
        .service
        .list_transfer_requests(limit, params.cursor.as_deref())
        .await?;
    Ok(Json(requests))
}

/// Get a single transfer request by ID
#[utoipa::path(
    get,
    path = "/transfer-requests/{id}",
    tag = "transfers",
    params(
        ("id" = String, Path, description = "Transfer Request ID")
    ),
    responses(
        (status = 200, description = "Transfer request found", body = TransferRequest),
        (status = 404, description = "Request not found", body = ErrorResponse),
        (status = 429, description = "Rate limit exceeded", body = RateLimitResponse),
        (status = 500, description = "Internal server error", body = ErrorResponse)
    )
)]
pub async fn get_transfer_request_handler(
    State(state): State<Arc<AppState>>,
    Path(id): Path<String>,
) -> Result<Json<TransferRequest>, AppError> {
    let request = state
        .service
        .get_transfer_request(&id)
        .await?
        .ok_or(AppError::Database(DatabaseError::NotFound(id)))?;
    Ok(Json(request))
}

/// Retry blockchain submission for a transfer request
#[utoipa::path(
    post,
    path = "/transfer-requests/{id}/retry",
    tag = "transfers",
    params(
        ("id" = String, Path, description = "Transfer Request ID")
    ),
    responses(
        (status = 200, description = "Retry successful", body = TransferRequest),
        (status = 400, description = "Request not eligible for retry", body = ErrorResponse),
        (status = 404, description = "Request not found", body = ErrorResponse),
        (status = 429, description = "Rate limit exceeded", body = RateLimitResponse),
        (status = 500, description = "Internal server error", body = ErrorResponse),
        (status = 503, description = "Blockchain unavailable", body = ErrorResponse)
    )
)]
pub async fn retry_blockchain_handler(
    State(state): State<Arc<AppState>>,
    Path(id): Path<String>,
) -> Result<Json<TransferRequest>, AppError> {
    let request = state.service.retry_blockchain_submission(&id).await?;
    Ok(Json(request))
}

/// Detailed health check
#[utoipa::path(
    get,
    path = "/health",
    tag = "health",
    responses(
        (status = 200, description = "Health status", body = HealthResponse)
    )
)]
pub async fn health_check_handler(State(state): State<Arc<AppState>>) -> Json<HealthResponse> {
    let health = state.service.health_check().await;
    Json(health)
}

/// Kubernetes liveness probe
#[utoipa::path(
    get,
    path = "/health/live",
    tag = "health",
    responses(
        (status = 200, description = "Application is alive")
    )
)]
pub async fn liveness_handler() -> StatusCode {
    StatusCode::OK
}

/// Kubernetes readiness probe
#[utoipa::path(
    get,
    path = "/health/ready",
    tag = "health",
    responses(
        (status = 200, description = "Application is ready to serve traffic"),
        (status = 503, description = "Application is not ready")
    )
)]
pub async fn readiness_handler(State(state): State<Arc<AppState>>) -> StatusCode {
    let health = state.service.health_check().await;
    match health.status {
        HealthStatus::Healthy | HealthStatus::Degraded => StatusCode::OK,
        HealthStatus::Unhealthy => StatusCode::SERVICE_UNAVAILABLE,
    }
}

/// Handle Helius webhook for transaction confirmation
///
/// Receives Enhanced Transaction events from Helius and updates transaction status.
/// Validates the Authorization header against the configured HELIUS_WEBHOOK_SECRET.
pub async fn helius_webhook_handler(
    State(state): State<Arc<AppState>>,
    headers: HeaderMap,
    Json(payload): Json<Vec<HeliusTransaction>>,
) -> Result<StatusCode, AppError> {
    // Validate webhook secret if configured
    if let Some(expected_secret) = &state.helius_webhook_secret {
        let auth_header = headers
            .get("Authorization")
            .and_then(|v| v.to_str().ok())
            .ok_or_else(|| AppError::Authentication("Missing Authorization header".to_string()))?;

        if auth_header != expected_secret {
            return Err(AppError::Authentication(
                "Invalid webhook secret".to_string(),
            ));
        }
    }

    // Process the webhook payload
    let tx_count = payload.len();
    let processed = state.service.process_helius_webhook(payload).await?;

    info!(
        received = %tx_count,
        processed = %processed,
        "Helius webhook processed"
    );

    Ok(StatusCode::OK)
}

impl IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        let (status, error_type, message) = match &self {
            AppError::Database(db_err) => match db_err {
                DatabaseError::Connection(_) => (
                    StatusCode::SERVICE_UNAVAILABLE,
                    "database_error",
                    self.to_string(),
                ),
                DatabaseError::NotFound(_) => {
                    (StatusCode::NOT_FOUND, "not_found", self.to_string())
                }
                DatabaseError::Duplicate(_) => {
                    (StatusCode::CONFLICT, "duplicate", self.to_string())
                }
                _ => (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    "database_error",
                    self.to_string(),
                ),
            },
            AppError::Blockchain(bc_err) => match bc_err {
                BlockchainError::Connection(_) => (
                    StatusCode::SERVICE_UNAVAILABLE,
                    "blockchain_error",
                    self.to_string(),
                ),
                BlockchainError::InsufficientFunds => (
                    StatusCode::PAYMENT_REQUIRED,
                    "insufficient_funds",
                    self.to_string(),
                ),
                BlockchainError::Timeout(_) => {
                    (StatusCode::GATEWAY_TIMEOUT, "timeout", self.to_string())
                }
                _ => (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    "blockchain_error",
                    self.to_string(),
                ),
            },
            AppError::ExternalService(ext_err) => match ext_err {
                ExternalServiceError::Unavailable(_) => (
                    StatusCode::BAD_GATEWAY,
                    "external_service_error",
                    self.to_string(),
                ),
                ExternalServiceError::Timeout(_) => {
                    (StatusCode::GATEWAY_TIMEOUT, "timeout", self.to_string())
                }
                ExternalServiceError::RateLimited(_) => (
                    StatusCode::TOO_MANY_REQUESTS,
                    "rate_limited",
                    self.to_string(),
                ),
                _ => (
                    StatusCode::BAD_GATEWAY,
                    "external_service_error",
                    self.to_string(),
                ),
            },
            AppError::Config(_) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "configuration_error",
                self.to_string(),
            ),
            AppError::Validation(_) => (
                StatusCode::BAD_REQUEST,
                "validation_error",
                self.to_string(),
            ),
            AppError::Authentication(_) => (
                StatusCode::UNAUTHORIZED,
                "authentication_error",
                self.to_string(),
            ),
            AppError::Authorization(_) => (
                StatusCode::FORBIDDEN,
                "authorization_error",
                self.to_string(),
            ),
            AppError::Serialization(_) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "serialization_error",
                self.to_string(),
            ),
            AppError::Deserialization(_) => (
                StatusCode::BAD_REQUEST,
                "deserialization_error",
                self.to_string(),
            ),
            AppError::Internal(_) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "internal_error",
                self.to_string(),
            ),
            AppError::NotSupported(_) => (
                StatusCode::NOT_IMPLEMENTED,
                "not_supported",
                self.to_string(),
            ),
            AppError::RateLimited => (
                StatusCode::TOO_MANY_REQUESTS,
                "rate_limited",
                "Rate limit exceeded".to_string(),
            ),
        };

        if status.is_server_error() {
            error!(error_type = %error_type, message = %message, "Server error");
        }

        let body = Json(ErrorResponse {
            error: ErrorDetail {
                r#type: error_type.to_string(),
                message,
            },
        });

        (status, body).into_response()
    }
}

===== ./api/mod.rs =====
//! The API layer, containing web handlers and routing.

pub mod handlers;
pub mod router;

pub use handlers::ApiDoc;
pub use router::{RateLimitConfig, create_router, create_router_with_rate_limit};

===== ./api/router.rs =====
//! HTTP routing configuration with rate limiting and OpenAPI documentation.

use std::num::NonZeroU32;
use std::sync::Arc;
use std::time::Duration;

use axum::{
    Json, Router,
    body::Body,
    extract::State,
    http::{Request, Response, StatusCode},
    middleware::{self, Next},
    response::IntoResponse,
    routing::{get, post},
};
use governor::{
    Quota, RateLimiter,
    clock::DefaultClock,
    state::{InMemoryState, NotKeyed},
};
use tower::ServiceBuilder;
use tower_http::{
    timeout::TimeoutLayer,
    trace::{DefaultMakeSpan, DefaultOnResponse, TraceLayer},
};
use tracing::Level;
use utoipa::OpenApi;
use utoipa_swagger_ui::SwaggerUi;

use crate::app::AppState;
use crate::domain::{ErrorDetail, ErrorResponse, RateLimitResponse};

use super::handlers::{
    ApiDoc, get_transfer_request_handler, health_check_handler, helius_webhook_handler,
    list_transfer_requests_handler, liveness_handler, readiness_handler, retry_blockchain_handler,
    submit_transfer_handler,
};

/// Rate limiter configuration
#[derive(Debug, Clone)]
pub struct RateLimitConfig {
    /// Requests per second for general endpoints
    pub general_rps: u32,
    /// Burst size for general endpoints
    pub general_burst: u32,
    /// Requests per second for health endpoints
    pub health_rps: u32,
    /// Burst size for health endpoints
    pub health_burst: u32,
}

impl Default for RateLimitConfig {
    fn default() -> Self {
        Self {
            general_rps: 10,
            general_burst: 20,
            health_rps: 100,
            health_burst: 100,
        }
    }
}

impl RateLimitConfig {
    /// Create config from environment variables
    pub fn from_env() -> Self {
        let general_rps = std::env::var("RATE_LIMIT_RPS")
            .ok()
            .and_then(|v| v.parse().ok())
            .unwrap_or(10);
        let general_burst = std::env::var("RATE_LIMIT_BURST")
            .ok()
            .and_then(|v| v.parse().ok())
            .unwrap_or(20);

        Self {
            general_rps,
            general_burst,
            health_rps: 100,
            health_burst: 100,
        }
    }
}

/// Shared rate limiter state
pub struct RateLimitState {
    transfers_limiter: RateLimiter<NotKeyed, InMemoryState, DefaultClock>,
    health_limiter: RateLimiter<NotKeyed, InMemoryState, DefaultClock>,
    config: RateLimitConfig,
}

impl RateLimitState {
    pub fn new(config: RateLimitConfig) -> Self {
        let transfers_quota = Quota::per_second(NonZeroU32::new(config.general_rps).unwrap())
            .allow_burst(NonZeroU32::new(config.general_burst).unwrap());
        let health_quota = Quota::per_second(NonZeroU32::new(config.health_rps).unwrap())
            .allow_burst(NonZeroU32::new(config.health_burst).unwrap());

        Self {
            transfers_limiter: RateLimiter::direct(transfers_quota),
            health_limiter: RateLimiter::direct(health_quota),
            config,
        }
    }
}

/// Rate limit middleware for transfers endpoints
async fn rate_limit_transfers_middleware(
    State(rate_limit): State<Arc<RateLimitState>>,
    request: Request<Body>,
    next: Next,
) -> Response<Body> {
    match rate_limit.transfers_limiter.check() {
        Ok(_) => {
            let mut response = next.run(request).await;
            // Add rate limit headers
            let headers = response.headers_mut();
            headers.insert(
                "X-RateLimit-Limit",
                rate_limit.config.general_rps.to_string().parse().unwrap(),
            );
            response
        }
        Err(not_until) => {
            let wait_time = not_until.wait_time_from(governor::clock::Clock::now(
                &governor::clock::DefaultClock::default(),
            ));
            let retry_after = wait_time.as_secs();

            let body = RateLimitResponse {
                error: ErrorDetail {
                    r#type: "rate_limited".to_string(),
                    message: "Rate limit exceeded. Please slow down your requests.".to_string(),
                },
                retry_after,
            };

            let mut response = (StatusCode::TOO_MANY_REQUESTS, Json(body)).into_response();
            let headers = response.headers_mut();
            headers.insert(
                "X-RateLimit-Limit",
                rate_limit.config.general_rps.to_string().parse().unwrap(),
            );
            headers.insert("X-RateLimit-Remaining", "0".parse().unwrap());
            headers.insert("Retry-After", retry_after.to_string().parse().unwrap());
            response
        }
    }
}

/// Rate limit middleware for health endpoints
async fn rate_limit_health_middleware(
    State(rate_limit): State<Arc<RateLimitState>>,
    request: Request<Body>,
    next: Next,
) -> Response<Body> {
    match rate_limit.health_limiter.check() {
        Ok(_) => next.run(request).await,
        Err(not_until) => {
            let wait_time = not_until.wait_time_from(governor::clock::Clock::now(
                &governor::clock::DefaultClock::default(),
            ));
            let retry_after = wait_time.as_secs();

            let body = ErrorResponse {
                error: ErrorDetail {
                    r#type: "rate_limited".to_string(),
                    message: "Rate limit exceeded".to_string(),
                },
            };

            let mut response = (StatusCode::TOO_MANY_REQUESTS, Json(body)).into_response();
            response
                .headers_mut()
                .insert("Retry-After", retry_after.to_string().parse().unwrap());
            response
        }
    }
}

/// Create router without rate limiting
pub fn create_router(app_state: Arc<AppState>) -> Router {
    let middleware = ServiceBuilder::new()
        .layer(
            TraceLayer::new_for_http()
                .make_span_with(DefaultMakeSpan::new().level(Level::INFO))
                .on_response(DefaultOnResponse::new().level(Level::INFO)),
        )
        .layer(TimeoutLayer::with_status_code(
            StatusCode::REQUEST_TIMEOUT,
            Duration::from_secs(30),
        ));

    // Transfer routes
    let transfer_routes = Router::new()
        .route(
            "/",
            post(submit_transfer_handler).get(list_transfer_requests_handler),
        )
        .route("/{id}", get(get_transfer_request_handler))
        .route("/{id}/retry", post(retry_blockchain_handler));

    // Health routes
    let health_routes = Router::new()
        .route("/", get(health_check_handler))
        .route("/live", get(liveness_handler))
        .route("/ready", get(readiness_handler));

    // Webhook routes (no rate limiting)
    let webhook_routes = Router::new().route("/helius", post(helius_webhook_handler));

    Router::new()
        .nest("/transfer-requests", transfer_routes)
        .nest("/webhooks", webhook_routes)
        .nest("/health", health_routes)
        .layer(middleware)
        .with_state(app_state)
        .merge(SwaggerUi::new("/swagger-ui").url("/api-docs/openapi.json", ApiDoc::openapi()))
}

/// Create router with rate limiting enabled
pub fn create_router_with_rate_limit(app_state: Arc<AppState>, config: RateLimitConfig) -> Router {
    let rate_limit_state = Arc::new(RateLimitState::new(config));

    let middleware = ServiceBuilder::new()
        .layer(
            TraceLayer::new_for_http()
                .make_span_with(DefaultMakeSpan::new().level(Level::INFO))
                .on_response(DefaultOnResponse::new().level(Level::INFO)),
        )
        .layer(TimeoutLayer::with_status_code(
            StatusCode::REQUEST_TIMEOUT,
            Duration::from_secs(30),
        ));

    // Transfer routes with rate limiting
    let transfer_routes = Router::new()
        .route(
            "/",
            post(submit_transfer_handler).get(list_transfer_requests_handler),
        )
        .route("/{id}", get(get_transfer_request_handler))
        .route("/{id}/retry", post(retry_blockchain_handler))
        .layer(middleware::from_fn_with_state(
            Arc::clone(&rate_limit_state),
            rate_limit_transfers_middleware,
        ));

    // Health routes with separate rate limiting
    let health_routes = Router::new()
        .route("/", get(health_check_handler))
        .route("/live", get(liveness_handler))
        .route("/ready", get(readiness_handler))
        .layer(middleware::from_fn_with_state(
            Arc::clone(&rate_limit_state),
            rate_limit_health_middleware,
        ));

    // Webhook routes (no rate limiting - webhooks need immediate delivery)
    let webhook_routes = Router::new().route("/helius", post(helius_webhook_handler));

    Router::new()
        .nest("/transfer-requests", transfer_routes)
        .nest("/webhooks", webhook_routes)
        .nest("/health", health_routes)
        .layer(middleware)
        .with_state(app_state)
        .merge(SwaggerUi::new("/swagger-ui").url("/api-docs/openapi.json", ApiDoc::openapi()))
}

#[cfg(test)]
mod tests {
    use axum::{
        Router,
        body::Body,
        http::{Request, StatusCode},
        middleware,
        response::IntoResponse,
        routing::get,
    };
    use std::sync::Arc;
    use tower::ServiceExt;

    use super::*;

    use crate::test_utils::{MockBlockchainClient, MockComplianceProvider, MockDatabaseClient};

    fn create_test_state() -> Arc<AppState> {
        let db = Arc::new(MockDatabaseClient::new());
        let bc = Arc::new(MockBlockchainClient::new());
        let cp = Arc::new(MockComplianceProvider::new());
        Arc::new(AppState::new(db as _, bc as _, cp as _))
    }

    mod rate_limit_config_tests {
        use super::*;

        #[test]
        fn test_rate_limit_config_default() {
            let config = RateLimitConfig::default();
            assert_eq!(config.general_rps, 10);
            assert_eq!(config.general_burst, 20);
        }

        #[test]
        fn test_rate_limit_config_default_health_values() {
            let config = RateLimitConfig::default();
            assert_eq!(config.health_rps, 100);
            assert_eq!(config.health_burst, 100);
        }

        #[test]
        fn test_rate_limit_config_custom() {
            let config = RateLimitConfig {
                general_rps: 50,
                general_burst: 100,
                health_rps: 200,
                health_burst: 200,
            };
            assert_eq!(config.general_rps, 50);
            assert_eq!(config.general_burst, 100);
            assert_eq!(config.health_rps, 200);
            assert_eq!(config.health_burst, 200);
        }

        #[test]
        fn test_rate_limit_config_debug() {
            let config = RateLimitConfig::default();
            let debug_str = format!("{:?}", config);
            assert!(debug_str.contains("RateLimitConfig"));
            assert!(debug_str.contains("general_rps"));
        }

        #[test]
        fn test_rate_limit_config_clone() {
            let config1 = RateLimitConfig {
                general_rps: 42,
                general_burst: 84,
                health_rps: 100,
                health_burst: 100,
            };
            let config2 = config1.clone();
            assert_eq!(config1.general_rps, config2.general_rps);
            assert_eq!(config1.general_burst, config2.general_burst);
        }
    }

    mod middleware_tests {
        use super::*;
        use http_body_util::BodyExt;

        async fn dummy_handler() -> impl IntoResponse {
            StatusCode::OK
        }

        #[tokio::test]
        async fn test_rate_limit_items_middleware_blocks_request() {
            let config = RateLimitConfig {
                general_rps: 1,
                general_burst: 1,
                ..Default::default()
            };

            let state = Arc::new(RateLimitState::new(config));

            let app =
                Router::new()
                    .route("/", get(dummy_handler))
                    .layer(middleware::from_fn_with_state(
                        state,
                        rate_limit_transfers_middleware,
                    ));

            app.clone()
                .oneshot(Request::builder().uri("/").body(Body::empty()).unwrap())
                .await
                .unwrap();

            let response = app
                .oneshot(Request::builder().uri("/").body(Body::empty()).unwrap())
                .await
                .unwrap();

            assert_eq!(response.status(), StatusCode::TOO_MANY_REQUESTS);
        }

        #[tokio::test]
        async fn test_rate_limit_success_includes_limit_header() {
            let config = RateLimitConfig {
                general_rps: 100,
                general_burst: 100,
                ..Default::default()
            };

            let state = Arc::new(RateLimitState::new(config));

            let app =
                Router::new()
                    .route("/", get(dummy_handler))
                    .layer(middleware::from_fn_with_state(
                        state,
                        rate_limit_transfers_middleware,
                    ));

            let response = app
                .oneshot(Request::builder().uri("/").body(Body::empty()).unwrap())
                .await
                .unwrap();

            assert_eq!(response.status(), StatusCode::OK);
            assert!(response.headers().contains_key("X-RateLimit-Limit"));
            assert_eq!(response.headers().get("X-RateLimit-Limit").unwrap(), "100");
        }

        #[tokio::test]
        async fn test_rate_limit_exceeded_includes_headers() {
            let config = RateLimitConfig {
                general_rps: 1,
                general_burst: 1,
                ..Default::default()
            };

            let state = Arc::new(RateLimitState::new(config));

            let app =
                Router::new()
                    .route("/", get(dummy_handler))
                    .layer(middleware::from_fn_with_state(
                        state,
                        rate_limit_transfers_middleware,
                    ));

            // Exhaust the limit
            app.clone()
                .oneshot(Request::builder().uri("/").body(Body::empty()).unwrap())
                .await
                .unwrap();

            // This should be rate limited
            let response = app
                .oneshot(Request::builder().uri("/").body(Body::empty()).unwrap())
                .await
                .unwrap();

            assert_eq!(response.status(), StatusCode::TOO_MANY_REQUESTS);
            assert!(response.headers().contains_key("X-RateLimit-Limit"));
            assert!(response.headers().contains_key("X-RateLimit-Remaining"));
            assert!(response.headers().contains_key("Retry-After"));
            assert_eq!(
                response.headers().get("X-RateLimit-Remaining").unwrap(),
                "0"
            );
        }

        #[tokio::test]
        async fn test_rate_limit_exceeded_response_body() {
            let config = RateLimitConfig {
                general_rps: 1,
                general_burst: 1,
                ..Default::default()
            };

            let state = Arc::new(RateLimitState::new(config));

            let app =
                Router::new()
                    .route("/", get(dummy_handler))
                    .layer(middleware::from_fn_with_state(
                        state,
                        rate_limit_transfers_middleware,
                    ));

            // Exhaust the limit
            app.clone()
                .oneshot(Request::builder().uri("/").body(Body::empty()).unwrap())
                .await
                .unwrap();

            let response = app
                .oneshot(Request::builder().uri("/").body(Body::empty()).unwrap())
                .await
                .unwrap();

            let body_bytes = response.into_body().collect().await.unwrap().to_bytes();
            let body_str = String::from_utf8_lossy(&body_bytes);
            assert!(body_str.contains("rate_limited"));
            assert!(body_str.contains("slow down"));
        }

        #[tokio::test]
        async fn test_health_rate_limit_middleware_allows_high_volume() {
            let config = RateLimitConfig {
                general_rps: 1,
                general_burst: 1,
                health_rps: 100,
                health_burst: 100,
            };

            let state = Arc::new(RateLimitState::new(config));

            let app =
                Router::new()
                    .route("/", get(dummy_handler))
                    .layer(middleware::from_fn_with_state(
                        state,
                        rate_limit_health_middleware,
                    ));

            // Should allow multiple requests
            for _ in 0..10 {
                let response = app
                    .clone()
                    .oneshot(Request::builder().uri("/").body(Body::empty()).unwrap())
                    .await
                    .unwrap();
                assert_eq!(response.status(), StatusCode::OK);
            }
        }
    }

    mod router_tests {
        use super::*;
        // use crate::app::AppState;

        #[tokio::test]
        async fn test_router_without_rate_limit_routes() {
            let app_state = create_test_state();
            let router = create_router(app_state);

            let res = router
                .oneshot(
                    Request::builder()
                        .uri("/health/live")
                        .body(Body::empty())
                        .unwrap(),
                )
                .await
                .unwrap();

            assert_eq!(res.status(), StatusCode::OK);
        }

        #[tokio::test]
        async fn test_router_items_get_nonexistent() {
            let app_state = create_test_state();
            let router = create_router(app_state);

            let res = router
                .oneshot(
                    Request::builder()
                        .uri("/transfer-requests/nonexistent-id")
                        .body(Body::empty())
                        .unwrap(),
                )
                .await
                .unwrap();

            // Should return 404 for non-existent item
            assert_eq!(res.status(), StatusCode::NOT_FOUND);
        }

        #[tokio::test]
        async fn test_router_with_rate_limit_items_accessible() {
            let app_state = create_test_state();
            let config = RateLimitConfig::default();
            let router = create_router_with_rate_limit(app_state, config);

            let res = router
                .oneshot(
                    Request::builder()
                        .uri("/transfer-requests/test-id")
                        .body(Body::empty())
                        .unwrap(),
                )
                .await
                .unwrap();

            // Should return 404 (not found), not forbidden or error
            assert_eq!(res.status(), StatusCode::NOT_FOUND);
        }
    }
}

===== ./app/mod.rs =====
//! Application layer containing business logic and shared state.

pub mod service;
pub mod state;
pub mod worker;

pub use service::AppService;
pub use state::AppState;
pub use worker::{BlockchainRetryWorker, WorkerConfig, spawn_worker, spawn_worker_with_privacy};

===== ./app/service.rs =====
//! Application service layer with graceful degradation.

use chrono::{Duration, Utc};
use std::sync::Arc;
use tracing::{error, info, instrument, warn};
use validator::Validate;

use crate::domain::{
    AppError, BlockchainClient, BlockchainStatus, ComplianceStatus, DatabaseClient, HealthResponse,
    HealthStatus, HeliusTransaction, PaginatedResponse, SubmitTransferRequest, TransferRequest,
    ValidationError,
};

/// Maximum number of retry attempts for blockchain submission
const MAX_RETRY_ATTEMPTS: i32 = 10;

/// Maximum backoff duration in seconds (5 minutes)
const MAX_BACKOFF_SECS: i64 = 300;

/// Application service containing business logic
pub struct AppService {
    db_client: Arc<dyn DatabaseClient>,
    blockchain_client: Arc<dyn BlockchainClient>,
    compliance_provider: Arc<dyn crate::domain::ComplianceProvider>,
}

impl AppService {
    #[must_use]
    pub fn new(
        db_client: Arc<dyn DatabaseClient>,
        blockchain_client: Arc<dyn BlockchainClient>,
        compliance_provider: Arc<dyn crate::domain::ComplianceProvider>,
    ) -> Self {
        Self {
            db_client,
            blockchain_client,
            compliance_provider,
        }
    }

    /// Submit a new transfer request for background processing.
    /// Validates, checks compliance, persists to database, and returns immediately.
    /// Blockchain submission is handled asynchronously by background workers.
    #[instrument(skip(self, request), fields(from = %request.from_address, to = %request.to_address))]
    pub async fn submit_transfer(
        &self,
        request: &SubmitTransferRequest,
    ) -> Result<TransferRequest, AppError> {
        // Cryptographic signature verification (MUST be first - before any state changes)
        request.verify_signature().map_err(|e| {
            warn!(from = %request.from_address, error = %e, "Signature verification failed");
            e
        })?;

        request.validate().map_err(|e| {
            warn!(error = %e, "Validation failed");
            AppError::Validation(ValidationError::Multiple(e.to_string()))
        })?;

        info!("Submitting new transfer request");

        // Compliance check (synchronous - fast)
        let compliance_status = self.compliance_provider.check_compliance(request).await?;
        if compliance_status == crate::domain::ComplianceStatus::Rejected {
            warn!(from = %request.from_address, to = %request.to_address, "Transfer rejected by compliance provider");
        }

        // Persist to database (single source of truth)
        let mut transfer_request = self.db_client.submit_transfer(request).await?;

        // Update compliance status
        if compliance_status != crate::domain::ComplianceStatus::Pending {
            self.db_client
                .update_compliance_status(&transfer_request.id, compliance_status)
                .await?;
        }
        transfer_request.compliance_status = compliance_status;

        // If rejected, return early - no blockchain submission needed
        if compliance_status == crate::domain::ComplianceStatus::Rejected {
            return Ok(transfer_request);
        }

        // Queue for background processing (Outbox Pattern: no blockchain call here!)
        self.db_client
            .update_blockchain_status(
                &transfer_request.id,
                BlockchainStatus::PendingSubmission,
                None,
                None,
                None,
            )
            .await?;
        transfer_request.blockchain_status = BlockchainStatus::PendingSubmission;

        info!(id = %transfer_request.id, "Transfer accepted for background processing");

        Ok(transfer_request)
    }

    /// Get a transfer request by ID
    #[instrument(skip(self))]
    pub async fn get_transfer_request(
        &self,
        id: &str,
    ) -> Result<Option<TransferRequest>, AppError> {
        self.db_client.get_transfer_request(id).await
    }

    /// List transfer requests with pagination
    #[instrument(skip(self))]
    pub async fn list_transfer_requests(
        &self,
        limit: i64,
        cursor: Option<&str>,
    ) -> Result<PaginatedResponse<TransferRequest>, AppError> {
        self.db_client.list_transfer_requests(limit, cursor).await
    }

    /// Retry blockchain submission for a specific request
    #[instrument(skip(self))]
    pub async fn retry_blockchain_submission(&self, id: &str) -> Result<TransferRequest, AppError> {
        let transfer_request = self
            .db_client
            .get_transfer_request(id)
            .await?
            .ok_or_else(|| {
                AppError::Database(crate::domain::DatabaseError::NotFound(id.to_string()))
            })?;

        if transfer_request.blockchain_status != BlockchainStatus::PendingSubmission
            && transfer_request.blockchain_status != BlockchainStatus::Failed
        {
            return Err(AppError::Validation(ValidationError::InvalidField {
                field: "blockchain_status".to_string(),
                message: "Request is not pending submission or failed".to_string(),
            }));
        }

        match self
            .blockchain_client
            .submit_transaction(&transfer_request)
            .await
        {
            Ok(signature) => {
                info!(id = %transfer_request.id, signature = %signature, "Retry submission successful");
                self.db_client
                    .update_blockchain_status(
                        id,
                        BlockchainStatus::Submitted,
                        Some(&signature),
                        None,
                        None,
                    )
                    .await?;
                let mut updated_request = transfer_request;
                updated_request.blockchain_status = BlockchainStatus::Submitted;
                updated_request.blockchain_signature = Some(signature);
                updated_request.blockchain_last_error = None;
                updated_request.blockchain_next_retry_at = None;
                Ok(updated_request)
            }
            Err(e) => {
                warn!(id = %transfer_request.id, error = ?e, "Retry submission failed");
                let retry_count = self.db_client.increment_retry_count(id).await?;
                let (status, next_retry) = if retry_count >= MAX_RETRY_ATTEMPTS {
                    (BlockchainStatus::Failed, None)
                } else {
                    let backoff = calculate_backoff(retry_count);
                    (
                        BlockchainStatus::PendingSubmission,
                        Some(Utc::now() + Duration::seconds(backoff)),
                    )
                };

                self.db_client
                    .update_blockchain_status(id, status, None, Some(&e.to_string()), next_retry)
                    .await?;

                Err(e)
            }
        }
    }

    /// Process pending blockchain submissions (called by background worker)
    #[instrument(skip(self))]
    pub async fn process_pending_submissions(&self, batch_size: i64) -> Result<usize, AppError> {
        let pending_requests = self
            .db_client
            .get_pending_blockchain_requests(batch_size)
            .await?;
        let count = pending_requests.len();

        if count == 0 {
            return Ok(0);
        }

        info!(count = count, "Processing pending blockchain submissions");

        for request in pending_requests {
            if let Err(e) = self.process_single_submission(&request).await {
                error!(id = %request.id, error = ?e, "Failed to process pending submission");
            }
        }

        Ok(count)
    }

    /// Process a single pending submission
    async fn process_single_submission(&self, request: &TransferRequest) -> Result<(), AppError> {
        // Defense in depth: Skip non-approved requests (should be filtered at DB level already)
        if request.compliance_status != ComplianceStatus::Approved {
            warn!(id = %request.id, status = ?request.compliance_status, "Skipping non-approved request");
            return Ok(());
        }

        // Delegate dispatch to blockchain client
        let result = self.blockchain_client.submit_transaction(request).await;

        match result {
            Ok(signature) => {
                let transfer_type = if request.token_mint.is_some() {
                    "Token"
                } else {
                    "SOL"
                };
                info!(id = %request.id, signature = %signature, r#type = %transfer_type, "Transfer successful");
                self.db_client
                    .update_blockchain_status(
                        &request.id,
                        BlockchainStatus::Submitted,
                        Some(&signature),
                        None,
                        None,
                    )
                    .await?;
            }
            Err(e) => {
                let transfer_type = if request.token_mint.is_some() {
                    "Token"
                } else {
                    "SOL"
                };
                warn!(id = %request.id, error = ?e, r#type = %transfer_type, "Transfer failed");
                let retry_count = self.db_client.increment_retry_count(&request.id).await?;
                let (status, next_retry) = if retry_count >= MAX_RETRY_ATTEMPTS {
                    (BlockchainStatus::Failed, None)
                } else {
                    let backoff = calculate_backoff(retry_count);
                    (
                        BlockchainStatus::PendingSubmission,
                        Some(Utc::now() + Duration::seconds(backoff)),
                    )
                };

                self.db_client
                    .update_blockchain_status(
                        &request.id,
                        status,
                        None,
                        Some(&e.to_string()),
                        next_retry,
                    )
                    .await?;
            }
        }

        Ok(())
    }

    /// Perform health check on all dependencies
    #[instrument(skip(self))]
    pub async fn health_check(&self) -> HealthResponse {
        let db_health = match self.db_client.health_check().await {
            Ok(()) => HealthStatus::Healthy,
            Err(_) => HealthStatus::Unhealthy,
        };
        let blockchain_health = match self.blockchain_client.health_check().await {
            Ok(()) => HealthStatus::Healthy,
            Err(_) => HealthStatus::Unhealthy,
        };
        HealthResponse::new(db_health, blockchain_health)
    }

    /// Process incoming Helius webhook transactions.
    /// Updates blockchain status for transactions we have initiated.
    /// Returns the number of transactions actually processed.
    #[instrument(skip(self, transactions), fields(tx_count = %transactions.len()))]
    pub async fn process_helius_webhook(
        &self,
        transactions: Vec<HeliusTransaction>,
    ) -> Result<usize, AppError> {
        let mut processed = 0;

        for tx in transactions {
            // Look up by signature to see if this is one of our transactions
            if let Some(request) = self
                .db_client
                .get_transfer_by_signature(&tx.signature)
                .await?
            {
                // Only update if currently in Submitted status (waiting for confirmation)
                if request.blockchain_status == BlockchainStatus::Submitted {
                    let (new_status, error_msg) = if tx.transaction_error.is_none() {
                        info!(id = %request.id, signature = %tx.signature, "Transaction confirmed via Helius webhook");
                        (BlockchainStatus::Confirmed, None)
                    } else {
                        let err = tx
                            .transaction_error
                            .as_ref()
                            .map(|e| e.to_string())
                            .unwrap_or_else(|| "Unknown transaction error".to_string());
                        warn!(id = %request.id, signature = %tx.signature, error = %err, "Transaction failed via Helius webhook");
                        (BlockchainStatus::Failed, Some(err))
                    };

                    self.db_client
                        .update_blockchain_status(
                            &request.id,
                            new_status,
                            None,
                            error_msg.as_deref(),
                            None,
                        )
                        .await?;

                    processed += 1;
                }
            }
        }

        info!(processed = %processed, "Helius webhook processing complete");
        Ok(processed)
    }
}

/// Calculate exponential backoff with maximum cap
fn calculate_backoff(retry_count: i32) -> i64 {
    let backoff = 2_i64.pow(retry_count.min(8) as u32);
    backoff.min(MAX_BACKOFF_SECS)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_backoff() {
        assert_eq!(calculate_backoff(0), 1);
        assert_eq!(calculate_backoff(1), 2);
        assert_eq!(calculate_backoff(2), 4);
        assert_eq!(calculate_backoff(3), 8);
        assert_eq!(calculate_backoff(4), 16);
        assert_eq!(calculate_backoff(5), 32);
        assert_eq!(calculate_backoff(6), 64);
        assert_eq!(calculate_backoff(7), 128);
        assert_eq!(calculate_backoff(8), 256);
        assert_eq!(calculate_backoff(9), 256); // Capped at 2^8
        assert_eq!(calculate_backoff(10), 256);
    }
}

===== ./app/state.rs =====
//! Application state management.

use std::sync::Arc;

use crate::domain::{BlockchainClient, DatabaseClient};
use crate::infra::privacy::PrivacyHealthCheckService;

use super::service::AppService;

/// Shared application state
#[derive(Clone)]
pub struct AppState {
    pub service: Arc<AppService>,
    pub db_client: Arc<dyn DatabaseClient>,
    pub blockchain_client: Arc<dyn BlockchainClient>,
    /// Helius webhook secret for authentication (optional)
    pub helius_webhook_secret: Option<String>,
    /// Privacy health check service for confidential transfers
    pub privacy_service: Option<Arc<PrivacyHealthCheckService>>,
}

impl AppState {
    /// Create a new application state
    #[must_use]
    pub fn new(
        db_client: Arc<dyn DatabaseClient>,
        blockchain_client: Arc<dyn BlockchainClient>,
        compliance_provider: Arc<dyn crate::domain::ComplianceProvider>,
    ) -> Self {
        Self::with_helius_secret(db_client, blockchain_client, compliance_provider, None)
    }

    /// Create a new application state with Helius webhook secret
    #[must_use]
    pub fn with_helius_secret(
        db_client: Arc<dyn DatabaseClient>,
        blockchain_client: Arc<dyn BlockchainClient>,
        compliance_provider: Arc<dyn crate::domain::ComplianceProvider>,
        helius_webhook_secret: Option<String>,
    ) -> Self {
        let service = Arc::new(AppService::new(
            Arc::clone(&db_client),
            Arc::clone(&blockchain_client),
            Arc::clone(&compliance_provider),
        ));
        Self {
            service,
            db_client,
            blockchain_client,
            helius_webhook_secret,
            privacy_service: None,
        }
    }

    /// Add privacy service to the application state (builder pattern)
    #[must_use]
    pub fn with_privacy_service(mut self, privacy_service: Arc<PrivacyHealthCheckService>) -> Self {
        self.privacy_service = Some(privacy_service);
        self
    }
}

===== ./app/worker.rs =====
//! Background worker for processing pending blockchain submissions.

use std::sync::Arc;
use std::time::Duration;
use tokio::sync::watch;
use tracing::{debug, error, info, warn};

use crate::domain::types::TransferType;
use crate::infra::privacy::PrivacyHealthCheckService;

use super::service::AppService;

/// Configuration for the background worker
#[derive(Debug, Clone)]
pub struct WorkerConfig {
    /// Interval between processing batches
    pub poll_interval: Duration,
    /// Number of items to process per batch
    pub batch_size: i64,
    /// Whether the worker is enabled
    pub enabled: bool,
    /// Whether to apply privacy health checks for confidential transfers
    pub enable_privacy_checks: bool,
}

impl Default for WorkerConfig {
    fn default() -> Self {
        Self {
            poll_interval: Duration::from_secs(10),
            batch_size: 10,
            enabled: true,
            enable_privacy_checks: true,
        }
    }
}

/// Background worker for processing pending blockchain submissions
pub struct BlockchainRetryWorker {
    service: Arc<AppService>,
    config: WorkerConfig,
    shutdown_rx: watch::Receiver<bool>,
    /// Privacy service for anonymity set health checks (used for confidential transfers)
    #[allow(dead_code)] // Scaffolded for future integration
    privacy_service: Option<Arc<PrivacyHealthCheckService>>,
}

impl BlockchainRetryWorker {
    /// Create a new worker instance
    pub fn new(
        service: Arc<AppService>,
        config: WorkerConfig,
        shutdown_rx: watch::Receiver<bool>,
    ) -> Self {
        Self {
            service,
            config,
            shutdown_rx,
            privacy_service: None,
        }
    }

    /// Create a new worker instance with privacy service
    pub fn with_privacy_service(
        service: Arc<AppService>,
        config: WorkerConfig,
        shutdown_rx: watch::Receiver<bool>,
        privacy_service: Arc<PrivacyHealthCheckService>,
    ) -> Self {
        Self {
            service,
            config,
            shutdown_rx,
            privacy_service: Some(privacy_service),
        }
    }

    /// Get the configured batch size
    #[must_use]
    pub fn batch_size(&self) -> i64 {
        self.config.batch_size
    }

    /// Run the worker loop
    pub async fn run(mut self) {
        if !self.config.enabled {
            info!("Blockchain retry worker is disabled");
            return;
        }

        info!(
            poll_interval = ?self.config.poll_interval,
            batch_size = self.config.batch_size,
            "Starting blockchain retry worker"
        );

        loop {
            tokio::select! {
                _ = tokio::time::sleep(self.config.poll_interval) => {
                    self.process_batch().await;
                }
                result = self.shutdown_rx.changed() => {
                    if result.is_ok() && *self.shutdown_rx.borrow() {
                        info!("Blockchain retry worker shutting down");
                        break;
                    }
                }
            }
        }
    }

    /// Execute a single tick of the worker loop (for testing)
    /// This processes one batch without the full loop infrastructure
    pub async fn run_once(&self) {
        if !self.config.enabled {
            return;
        }
        self.process_batch().await;
    }

    /// Process a batch of pending submissions
    pub async fn process_batch(&self) {
        match self
            .service
            .process_pending_submissions(self.config.batch_size)
            .await
        {
            Ok(0) => {
                // No pending items, nothing to log
            }
            Ok(count) => {
                info!(count = count, "Processed pending blockchain submissions");
            }
            Err(e) => {
                error!(error = ?e, "Error processing pending submissions");
            }
        }
    }

    /// Check privacy health for confidential transfers
    ///
    /// Returns the recommended delay in seconds, or 0 for immediate processing.
    /// Only applies to confidential transfers when privacy checks are enabled.
    #[allow(dead_code)] // Scaffolded for future integration
    async fn check_privacy_health(&self, request: &crate::domain::TransferRequest) -> u64 {
        // Only check confidential transfers
        let is_confidential = matches!(request.transfer_details, TransferType::Confidential { .. });

        if !is_confidential || !self.config.enable_privacy_checks {
            return 0;
        }

        let privacy_service = match &self.privacy_service {
            Some(s) => s,
            None => return 0,
        };

        let token_mint = match &request.token_mint {
            Some(mint) => mint,
            None => return 0,
        };

        debug!(
            request_id = %request.id,
            token_mint = %token_mint,
            "Checking privacy health for confidential transfer"
        );

        let health = privacy_service.check_health(token_mint).await;

        if health.is_healthy {
            0
        } else {
            let delay = health.recommended_delay_secs.unwrap_or(0);
            if delay > 0 {
                warn!(
                    request_id = %request.id,
                    delay_secs = delay,
                    recent_tx_count = health.recent_tx_count,
                    "Privacy health check: delaying submission for anonymity"
                );
            }
            delay
        }
    }
}

/// Spawn the background worker as a tokio task
pub fn spawn_worker(
    service: Arc<AppService>,
    config: WorkerConfig,
) -> (tokio::task::JoinHandle<()>, watch::Sender<bool>) {
    let (shutdown_tx, shutdown_rx) = watch::channel(false);
    let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);
    let handle = tokio::spawn(worker.run());
    (handle, shutdown_tx)
}

/// Spawn the background worker with privacy service
pub fn spawn_worker_with_privacy(
    service: Arc<AppService>,
    config: WorkerConfig,
    privacy_service: Arc<PrivacyHealthCheckService>,
) -> (tokio::task::JoinHandle<()>, watch::Sender<bool>) {
    let (shutdown_tx, shutdown_rx) = watch::channel(false);
    let worker =
        BlockchainRetryWorker::with_privacy_service(service, config, shutdown_rx, privacy_service);
    let handle = tokio::spawn(worker.run());
    (handle, shutdown_tx)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::{
        BlockchainStatus, ComplianceStatus, DatabaseClient, SubmitTransferRequest, TransferType,
    };
    use crate::test_utils::{
        MockBlockchainClient, MockComplianceProvider, MockConfig, MockDatabaseClient,
    };

    fn create_test_service() -> Arc<AppService> {
        let db = Arc::new(MockDatabaseClient::new());
        let bc = Arc::new(MockBlockchainClient::new());
        let cp = Arc::new(MockComplianceProvider::new());
        Arc::new(AppService::new(db as _, bc as _, cp as _))
    }

    #[test]
    fn test_worker_config_default() {
        let config = WorkerConfig::default();
        assert_eq!(config.poll_interval, Duration::from_secs(10));
        assert_eq!(config.batch_size, 10);
        assert!(config.enabled);
    }

    #[test]
    fn test_worker_config_custom() {
        let config = WorkerConfig {
            poll_interval: Duration::from_secs(5),
            batch_size: 20,
            enabled: false,
            enable_privacy_checks: false,
        };
        assert_eq!(config.poll_interval, Duration::from_secs(5));
        assert_eq!(config.batch_size, 20);
        assert!(!config.enabled);
    }

    #[test]
    fn test_worker_config_debug() {
        let config = WorkerConfig::default();
        let debug_str = format!("{:?}", config);
        assert!(debug_str.contains("WorkerConfig"));
        assert!(debug_str.contains("poll_interval"));
        assert!(debug_str.contains("batch_size"));
    }

    #[test]
    fn test_worker_config_clone() {
        let config1 = WorkerConfig {
            poll_interval: Duration::from_secs(30),
            batch_size: 50,
            enabled: true,
            enable_privacy_checks: false,
        };
        let config2 = config1.clone();
        assert_eq!(config1.poll_interval, config2.poll_interval);
        assert_eq!(config1.batch_size, config2.batch_size);
        assert_eq!(config1.enabled, config2.enabled);
    }

    #[tokio::test]
    async fn test_worker_disabled_returns_immediately() {
        let service = create_test_service();
        let config = WorkerConfig {
            poll_interval: Duration::from_millis(100),
            batch_size: 10,
            enabled: false, // Disabled
            enable_privacy_checks: false,
        };
        let (_, shutdown_rx) = watch::channel(false);
        let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);

        // Should return immediately without blocking
        let start = std::time::Instant::now();
        worker.run().await;
        let elapsed = start.elapsed();

        // Should complete almost instantly (less than 50ms)
        assert!(elapsed < Duration::from_millis(50));
    }

    #[tokio::test]
    async fn test_worker_shutdown_via_channel() {
        let service = create_test_service();
        let config = WorkerConfig {
            poll_interval: Duration::from_secs(60), // Long poll so it doesn't trigger
            batch_size: 10,
            enabled: true,
            enable_privacy_checks: false,
        };
        let (shutdown_tx, shutdown_rx) = watch::channel(false);
        let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);

        // Spawn worker in background
        let handle = tokio::spawn(worker.run());

        // Give it a moment to start
        tokio::time::sleep(Duration::from_millis(50)).await;

        // Send shutdown signal
        shutdown_tx.send(true).unwrap();

        // Worker should complete within reasonable time
        let result = tokio::time::timeout(Duration::from_secs(2), handle).await;
        assert!(result.is_ok(), "Worker should shutdown within 2 seconds");
    }

    #[tokio::test]
    async fn test_spawn_worker_returns_handles() {
        let service = create_test_service();
        let config = WorkerConfig {
            poll_interval: Duration::from_secs(60),
            batch_size: 10,
            enabled: false, // Disabled so it returns immediately
            enable_privacy_checks: false,
        };

        let (handle, shutdown_tx) = spawn_worker(service, config);

        // Wait for disabled worker to finish (it returns immediately when disabled)
        let result = tokio::time::timeout(Duration::from_secs(1), handle).await;
        assert!(
            result.is_ok(),
            "Worker should complete within 1 second when disabled"
        );

        // Shutdown sender should still be usable (no panic on send)
        let _ = shutdown_tx.send(true);
    }

    #[tokio::test]
    async fn test_worker_new_construction() {
        let service = create_test_service();
        let config = WorkerConfig::default();
        let (_, shutdown_rx) = watch::channel(false);

        let worker = BlockchainRetryWorker::new(Arc::clone(&service), config.clone(), shutdown_rx);

        // Worker should be constructed without panicking
        // Since fields are private, we verify by running it (which tests all the fields were set)
        drop(worker); // Just ensure it was created successfully
    }

    // --- NEW TESTS: run_once and process_batch ---

    #[tokio::test]
    async fn test_run_once_disabled_returns_immediately() {
        let service = create_test_service();
        let config = WorkerConfig {
            poll_interval: Duration::from_millis(100),
            batch_size: 10,
            enabled: false,
            enable_privacy_checks: false,
        };
        let (_, shutdown_rx) = watch::channel(false);
        let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);

        let start = std::time::Instant::now();
        worker.run_once().await;
        let elapsed = start.elapsed();

        // Should complete instantly when disabled
        assert!(elapsed < Duration::from_millis(10));
    }

    #[tokio::test]
    async fn test_run_once_enabled_calls_process_batch() {
        let service = create_test_service();
        let config = WorkerConfig {
            poll_interval: Duration::from_secs(60),
            batch_size: 5,
            enabled: true,
            enable_privacy_checks: false,
        };
        let (_, shutdown_rx) = watch::channel(false);
        let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);

        // run_once should complete without hanging (even with no pending items)
        let result = tokio::time::timeout(Duration::from_secs(1), worker.run_once()).await;
        assert!(result.is_ok(), "run_once should complete within 1 second");
    }

    #[tokio::test]
    async fn test_batch_size_accessor() {
        let service = create_test_service();
        let config = WorkerConfig {
            poll_interval: Duration::from_secs(10),
            batch_size: 42,
            enabled: true,
            enable_privacy_checks: false,
        };
        let (_, shutdown_rx) = watch::channel(false);
        let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);

        assert_eq!(worker.batch_size(), 42);
    }

    #[tokio::test]
    async fn test_process_batch_with_no_pending_items() {
        let service = create_test_service();
        let config = WorkerConfig {
            poll_interval: Duration::from_secs(10),
            batch_size: 10,
            enabled: true,
            enable_privacy_checks: false,
        };
        let (_, shutdown_rx) = watch::channel(false);
        let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);

        // Should complete without panic when no items
        worker.process_batch().await;
    }

    #[tokio::test]
    async fn test_process_batch_handles_service_error() {
        // Use a failing database client
        let db = Arc::new(MockDatabaseClient::with_config(MockConfig::failure(
            "Database error",
        )));
        let bc = Arc::new(MockBlockchainClient::new());
        let cp = Arc::new(MockComplianceProvider::new());
        let service = Arc::new(AppService::new(db as _, bc as _, cp as _));

        let config = WorkerConfig {
            poll_interval: Duration::from_secs(10),
            batch_size: 10,
            enabled: true,
            enable_privacy_checks: false,
        };
        let (_, shutdown_rx) = watch::channel(false);
        let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);

        // Should not panic - errors are logged
        worker.process_batch().await;
    }

    #[tokio::test]
    async fn test_worker_with_tokio_time_pause() {
        tokio::time::pause();

        let service = create_test_service();
        let config = WorkerConfig {
            poll_interval: Duration::from_secs(60),
            batch_size: 10,
            enabled: true,
            enable_privacy_checks: false,
        };
        let (shutdown_tx, shutdown_rx) = watch::channel(false);
        let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);

        let handle = tokio::spawn(worker.run());

        // Advance time past the poll interval
        tokio::time::advance(Duration::from_secs(61)).await;

        // Send shutdown signal
        shutdown_tx.send(true).unwrap();

        // Worker should shutdown
        let result = tokio::time::timeout(Duration::from_secs(1), handle).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_worker_multiple_ticks_with_time_control() {
        tokio::time::pause();

        let service = create_test_service();
        let config = WorkerConfig {
            poll_interval: Duration::from_secs(5),
            batch_size: 10,
            enabled: true,
            enable_privacy_checks: false,
        };
        let (shutdown_tx, shutdown_rx) = watch::channel(false);
        let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);

        let handle = tokio::spawn(worker.run());

        // Advance through multiple poll intervals
        for _ in 0..3 {
            tokio::time::advance(Duration::from_secs(6)).await;
            tokio::task::yield_now().await;
        }

        // Shutdown
        shutdown_tx.send(true).unwrap();
        let result = tokio::time::timeout(Duration::from_secs(1), handle).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_spawn_worker_with_enabled_config() {
        let service = create_test_service();
        let config = WorkerConfig {
            poll_interval: Duration::from_secs(60),
            batch_size: 10,
            enabled: true,
            enable_privacy_checks: false,
        };

        let (handle, shutdown_tx) = spawn_worker(service, config);

        // Give it a moment to start
        tokio::time::sleep(Duration::from_millis(50)).await;

        // Shutdown
        shutdown_tx.send(true).unwrap();

        // Should complete
        let result = tokio::time::timeout(Duration::from_secs(2), handle).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_worker_shutdown_channel_closed() {
        let service = create_test_service();
        let config = WorkerConfig {
            poll_interval: Duration::from_secs(60),
            batch_size: 10,
            enabled: true,
            enable_privacy_checks: false,
        };
        let (shutdown_tx, shutdown_rx) = watch::channel(false);
        let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);

        let handle = tokio::spawn(worker.run());

        // Drop the sender - this should trigger an error in changed()
        drop(shutdown_tx);

        // Worker should eventually notice and handle the closed channel
        // Give it a moment to process
        tokio::time::sleep(Duration::from_millis(100)).await;

        // Cancel the task since it won't shutdown naturally
        handle.abort();
    }

    #[tokio::test]
    async fn test_run_once_processes_pending_items() {
        let db = Arc::new(MockDatabaseClient::new());
        let bc = Arc::new(MockBlockchainClient::new());

        // Create a request that needs processing
        let request = SubmitTransferRequest {
            from_address: "AddressA".to_string(),
            to_address: "AddressB".to_string(),
            transfer_details: TransferType::Public {
                amount: 1_500_000_000,
            },
            token_mint: None,
            signature: "dummy_sig".to_string(),
        };
        let tr = db.submit_transfer(&request).await.unwrap();

        // Update to pending submission status
        db.update_blockchain_status(
            &tr.id,
            BlockchainStatus::PendingSubmission,
            None,
            None,
            None,
        )
        .await
        .unwrap();

        // Set compliance status to Approved (required for worker to process)
        db.update_compliance_status(&tr.id, ComplianceStatus::Approved)
            .await
            .unwrap();

        let cp = Arc::new(MockComplianceProvider::new());
        let service = Arc::new(AppService::new(db.clone() as _, bc as _, cp as _));

        let config = WorkerConfig {
            poll_interval: Duration::from_secs(10),
            batch_size: 10,
            enabled: true,
            enable_privacy_checks: false,
        };
        let (_, shutdown_rx) = watch::channel(false);
        let worker = BlockchainRetryWorker::new(service, config, shutdown_rx);

        // Process the pending item
        worker.run_once().await;

        // Verify the item was processed
        let updated = db.get_transfer_request(&tr.id).await.unwrap().unwrap();
        assert_eq!(updated.blockchain_status, BlockchainStatus::Submitted);
    }

    #[test]
    fn test_worker_config_zero_batch_size() {
        let config = WorkerConfig {
            poll_interval: Duration::from_secs(10),
            batch_size: 0,
            enabled: true,
            enable_privacy_checks: false,
        };
        assert_eq!(config.batch_size, 0);
    }

    #[test]
    fn test_worker_config_very_short_poll_interval() {
        let config = WorkerConfig {
            poll_interval: Duration::from_millis(1),
            batch_size: 10,
            enabled: true,
            enable_privacy_checks: false,
        };
        assert_eq!(config.poll_interval, Duration::from_millis(1));
    }
}

===== ./bin/generate_transfer_request.rs =====
//! CLI utility to generate valid transfer requests with proper Ed25519 signatures.
//!
//! Usage:
//!   cargo run --bin generate_transfer_request              # Public transfer
//!   cargo run --bin generate_transfer_request -- --confidential  # Confidential transfer with ZK proofs

use base64::Engine;
use base64::engine::general_purpose::STANDARD as BASE64_STANDARD;
use ed25519_dalek::{Signer, SigningKey};
use rand::rngs::OsRng;
use solana_compliance_relayer::domain::types::{SubmitTransferRequest, TransferType};
use solana_sdk::pubkey::Pubkey;

// ZK cryptography imports for confidential transfers
use solana_zk_sdk::encryption::{
    auth_encryption::{AeCiphertext, AeKey},
    elgamal::{ElGamalCiphertext, ElGamalKeypair},
};
use spl_token_confidential_transfer_proof_generation::transfer::transfer_split_proof_data;

fn main() {
    let args: Vec<String> = std::env::args().collect();
    let is_confidential = args.iter().any(|arg| arg == "--confidential");

    // 1. Generate a random Ed25519 keypair for transaction signing
    let mut csprng = OsRng;
    let signing_key = SigningKey::generate(&mut csprng);
    let verify_key = signing_key.verifying_key();

    // Convert to Solana Pubkeys for consistent display
    let from_pubkey = Pubkey::try_from(verify_key.to_bytes()).unwrap();
    // Use a random destination address
    let to_pubkey = Pubkey::new_unique();

    println!("Generated Keypair:");
    println!("   Public Key (from_address): {}", from_pubkey);
    // Note: In a real app never print private keys. This is a dev tool.
    println!("   Private Key (keep safe):   {:?}", signing_key.to_bytes());
    println!("\n--------------------------------------------------\n");

    // 2. Prepare request data based on transfer type
    let (transfer_details, token_mint, amount_part): (TransferType, Option<String>, String) =
        if is_confidential {
            generate_confidential_transfer()
        } else {
            let amount = 1_000_000_000u64; // 1 SOL
            (TransferType::Public { amount }, None, amount.to_string())
        };

    // Construct the message exactly as the server expects for signing:
    // "{from_address}:{to_address}:{amount|confidential}:{token_mint|SOL}"
    let mint_str = token_mint.as_deref().unwrap_or("SOL");
    let message = format!("{}:{}:{}:{}", from_pubkey, to_pubkey, amount_part, mint_str);

    println!("Signing Message: \"{}\"", message);

    // 3. Sign the message
    let signature = signing_key.sign(message.as_bytes());
    let signature_bs58 = bs58::encode(signature.to_bytes()).into_string();

    // 4. Construct the Request Object
    let request = SubmitTransferRequest {
        from_address: from_pubkey.to_string(),
        to_address: to_pubkey.to_string(),
        transfer_details,
        token_mint,
        signature: signature_bs58.clone(),
    };

    // 5. Generate the CURL command
    let json_body = serde_json::to_string_pretty(&request).unwrap();
    let curl_cmd = format!(
        "curl -X POST 'http://localhost:3000/transfer-requests' \\\n  -H 'Content-Type: application/json' \\\n  -d '{}'",
        json_body
    );

    println!("\nGenerated curl command:\n");
    println!("{}", curl_cmd);
}

/// Generate a confidential transfer with real ZK proofs.
///
/// This simulates a source account with a known balance, generates all required
/// ElGamal/AES cryptographic keys, and produces valid ZK proofs for the transfer.
fn generate_confidential_transfer() -> (TransferType, Option<String>, String) {
    println!("Generating CONFIDENTIAL transfer with real ZK proofs...\n");

    // Simulated account state
    const INITIAL_BALANCE: u64 = 10_000_000_000; // 10 SOL in lamports
    const TRANSFER_AMOUNT: u64 = 1_000_000_000; // 1 SOL in lamports

    // Generate cryptographic keys
    let source_elgamal_keypair = ElGamalKeypair::new_rand();
    let destination_elgamal_keypair = ElGamalKeypair::new_rand();
    let aes_key = AeKey::new_rand();

    println!("Simulated account state:");
    println!(
        "Initial balance: {} lamports ({} SOL)",
        INITIAL_BALANCE,
        INITIAL_BALANCE / 1_000_000_000
    );
    println!(
        "Transfer amount: {} lamports ({} SOL)",
        TRANSFER_AMOUNT,
        TRANSFER_AMOUNT / 1_000_000_000
    );
    println!(
        "Remaining balance: {} lamports ({} SOL)",
        INITIAL_BALANCE - TRANSFER_AMOUNT,
        (INITIAL_BALANCE - TRANSFER_AMOUNT) / 1_000_000_000
    );

    // Encrypt the current balance as ElGamal ciphertext (what's stored on-chain)
    let current_available_balance: ElGamalCiphertext =
        source_elgamal_keypair.pubkey().encrypt(INITIAL_BALANCE);

    // Encrypt the current balance as AeCiphertext (decryptable by owner)
    let current_decryptable_balance: AeCiphertext = aes_key.encrypt(INITIAL_BALANCE);

    // Generate the ZK proofs for the transfer
    println!("\nGenerating ZK proofs (this may take a moment)...");

    let proof_data = transfer_split_proof_data(
        &current_available_balance,
        &current_decryptable_balance,
        TRANSFER_AMOUNT,
        &source_elgamal_keypair,
        &aes_key,
        destination_elgamal_keypair.pubkey(),
        None, // No auditor
    )
    .expect("Failed to generate ZK proofs");

    println!("ZK proofs generated successfully!");

    // Extract and encode the proofs
    // The equality proof data
    let equality_proof_bytes = bytemuck::bytes_of(&proof_data.equality_proof_data);
    let equality_proof_base64 = BASE64_STANDARD.encode(equality_proof_bytes);

    // The ciphertext validity proof (includes the grouped ciphertext)
    let validity_proof = &proof_data.ciphertext_validity_proof_data_with_ciphertext;
    let validity_proof_bytes = bytemuck::bytes_of(&validity_proof.proof_data);
    let ciphertext_validity_proof_base64 = BASE64_STANDARD.encode(validity_proof_bytes);

    // The range proof
    let range_proof_bytes = bytemuck::bytes_of(&proof_data.range_proof_data);
    let range_proof_base64 = BASE64_STANDARD.encode(range_proof_bytes);

    // Calculate new decryptable balance after transfer
    let new_balance = INITIAL_BALANCE - TRANSFER_AMOUNT;
    let new_decryptable_balance: AeCiphertext = aes_key.encrypt(new_balance);
    let new_decryptable_balance_bytes = new_decryptable_balance.to_bytes();
    let new_decryptable_balance_base64 = BASE64_STANDARD.encode(new_decryptable_balance_bytes);

    // Print proof sizes for verification
    println!("\nProof sizes:");
    println!(
        "Equality proof:            {} bytes",
        equality_proof_bytes.len()
    );
    println!(
        "Ciphertext validity proof: {} bytes",
        validity_proof_bytes.len()
    );
    println!(
        "Range proof:               {} bytes",
        range_proof_bytes.len()
    );
    println!("New decryptable balance:   36 bytes");

    // Use a random token mint for the confidential transfer
    let token_mint = Pubkey::new_unique().to_string();

    let transfer_details = TransferType::Confidential {
        new_decryptable_available_balance: new_decryptable_balance_base64,
        equality_proof: equality_proof_base64,
        ciphertext_validity_proof: ciphertext_validity_proof_base64,
        range_proof: range_proof_base64,
    };

    (
        transfer_details,
        Some(token_mint),
        "confidential".to_string(),
    )
}

===== ./domain/error.rs =====
//! Application error types with proper error chaining.

use thiserror::Error;

#[derive(Error, Debug, Clone)]
pub enum DatabaseError {
    #[error("Connection failed: {0}")]
    Connection(String),
    #[error("Query execution failed: {0}")]
    Query(String),
    #[error("Record not found: {0}")]
    NotFound(String),
    #[error("Duplicate record: {0}")]
    Duplicate(String),
    #[error("Pool exhausted: {0}")]
    PoolExhausted(String),
    #[error("Migration failed: {0}")]
    Migration(String),
}

#[derive(Error, Debug, Clone)]
pub enum BlockchainError {
    #[error("Connection failed: {0}")]
    Connection(String),
    #[error("RPC call failed: {0}")]
    RpcError(String),
    #[error("Transaction failed: {0}")]
    TransactionFailed(String),
    #[error("Invalid signature: {0}")]
    InvalidSignature(String),
    #[error("Wallet error: {0}")]
    WalletError(String),
    #[error("Insufficient funds for transaction")]
    InsufficientFunds,
    #[error("Timeout waiting for confirmation: {0}")]
    Timeout(String),
    #[error("Helius API error: {0}")]
    HeliusApiError(String),
    #[error("DAS compliance check failed: {0}")]
    DasComplianceFailed(String),
    #[error("QuickNode API error: {0}")]
    QuickNodeApiError(String),
    #[error("Jito bundle submission failed: {0}")]
    JitoBundleFailed(String),
    #[error("Private submission unavailable, falling back: {0}")]
    PrivateSubmissionFallback(String),
}

#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("Missing environment variable: {0}")]
    MissingEnvVar(String),
    #[error("Invalid value for '{key}': {message}")]
    InvalidValue { key: String, message: String },
    #[error("Parse error: {0}")]
    ParseError(String),
}

impl From<&str> for ConfigError {
    fn from(s: &str) -> Self {
        ConfigError::ParseError(s.to_string())
    }
}

#[derive(Error, Debug)]
pub enum ValidationError {
    #[error("Invalid field '{field}': {message}")]
    InvalidField { field: String, message: String },
    #[error("Missing required field: {0}")]
    MissingField(String),
    #[error("Invalid format: {0}")]
    InvalidFormat(String),
    #[error("Invalid address: {0}")]
    InvalidAddress(String),
    #[error("Validation failed: {0}")]
    Multiple(String),
}

impl From<&str> for ValidationError {
    fn from(s: &str) -> Self {
        ValidationError::InvalidFormat(s.to_string())
    }
}

#[derive(Error, Debug)]
pub enum ExternalServiceError {
    #[error("HTTP request failed: {0}")]
    HttpError(String),
    #[error("Service unavailable: {0}")]
    Unavailable(String),
    #[error("Timeout: {0}")]
    Timeout(String),
    #[error("Rate limited: {0}")]
    RateLimited(String),
    #[error("Configuration error: {0}")]
    Configuration(String),
    #[error("Network error: {0}")]
    Network(String),
    #[error("API error (status {status_code}): {message}")]
    ApiError { status_code: u16, message: String },
    #[error("Parse error: {0}")]
    ParseError(String),
}

#[derive(Error, Debug)]
pub enum AppError {
    #[error(transparent)]
    Database(#[from] DatabaseError),
    #[error(transparent)]
    Blockchain(#[from] BlockchainError),
    #[error(transparent)]
    ExternalService(#[from] ExternalServiceError),
    #[error(transparent)]
    Config(#[from] ConfigError),
    #[error(transparent)]
    Validation(#[from] ValidationError),
    #[error("Authentication failed: {0}")]
    Authentication(String),
    #[error("Authorization denied: {0}")]
    Authorization(String),
    #[error("Serialization error: {0}")]
    Serialization(String),
    #[error("Deserialization error: {0}")]
    Deserialization(String),
    #[error("Internal error: {0}")]
    Internal(String),
    #[error("Operation not supported: {0}")]
    NotSupported(String),
    #[error("Rate limit exceeded")]
    RateLimited,
}

impl From<serde_json::Error> for AppError {
    fn from(err: serde_json::Error) -> Self {
        AppError::Serialization(err.to_string())
    }
}

impl From<validator::ValidationErrors> for AppError {
    fn from(err: validator::ValidationErrors) -> Self {
        AppError::Validation(ValidationError::Multiple(err.to_string()))
    }
}

impl From<sqlx::Error> for DatabaseError {
    fn from(err: sqlx::Error) -> Self {
        match err {
            sqlx::Error::RowNotFound => DatabaseError::NotFound("Row not found".to_string()),
            sqlx::Error::PoolTimedOut => DatabaseError::PoolExhausted("Pool timed out".to_string()),
            sqlx::Error::Database(db_err) => {
                if db_err.code().is_some_and(|code| code == "23505") {
                    return DatabaseError::Duplicate(db_err.message().to_string());
                }
                DatabaseError::Query(db_err.message().to_string())
            }
            _ => DatabaseError::Query(err.to_string()),
        }
    }
}

impl From<sqlx::migrate::MigrateError> for AppError {
    fn from(err: sqlx::migrate::MigrateError) -> Self {
        AppError::Database(DatabaseError::Migration(err.to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_database_error_conversions() {
        let not_found = DatabaseError::from(sqlx::Error::RowNotFound);
        assert!(matches!(not_found, DatabaseError::NotFound(_)));

        // Test pool timeout
        let pool_timeout = DatabaseError::from(sqlx::Error::PoolTimedOut);
        assert!(matches!(pool_timeout, DatabaseError::PoolExhausted(_)));

        // Simulate fallback for unknown errors
        let generic = DatabaseError::from(sqlx::Error::WorkerCrashed);
        assert!(matches!(generic, DatabaseError::Query(_)));
    }

    #[test]
    fn test_validation_conversion() {
        use validator::Validate;

        #[derive(Validate)]
        struct TestStruct {
            #[validate(length(min = 1))]
            val: String,
        }

        let s = TestStruct {
            val: "".to_string(),
        };
        let err = s.validate().unwrap_err();
        let app_err = AppError::from(err);

        assert!(matches!(
            app_err,
            AppError::Validation(ValidationError::Multiple(_))
        ));
    }

    #[test]
    fn test_config_error_from_str() {
        let err: ConfigError = "parse failure".into();
        assert!(matches!(err, ConfigError::ParseError(msg) if msg == "parse failure"));
    }

    #[test]
    fn test_validation_error_from_str() {
        let err: ValidationError = "invalid format".into();
        assert!(matches!(err, ValidationError::InvalidFormat(msg) if msg == "invalid format"));
    }

    #[test]
    fn test_serde_json_error_conversion() {
        let json_err = serde_json::from_str::<String>("invalid json").unwrap_err();
        let app_err = AppError::from(json_err);
        assert!(matches!(app_err, AppError::Serialization(_)));
    }

    #[test]
    fn test_database_error_display() {
        let err = DatabaseError::Connection("timeout".to_string());
        assert_eq!(err.to_string(), "Connection failed: timeout");

        let err = DatabaseError::Query("syntax error".to_string());
        assert_eq!(err.to_string(), "Query execution failed: syntax error");

        let err = DatabaseError::NotFound("item_123".to_string());
        assert_eq!(err.to_string(), "Record not found: item_123");

        let err = DatabaseError::Duplicate("unique violation".to_string());
        assert_eq!(err.to_string(), "Duplicate record: unique violation");

        let err = DatabaseError::PoolExhausted("no connections".to_string());
        assert_eq!(err.to_string(), "Pool exhausted: no connections");

        let err = DatabaseError::Migration("failed".to_string());
        assert_eq!(err.to_string(), "Migration failed: failed");
    }

    #[test]
    fn test_blockchain_error_display() {
        let err = BlockchainError::Connection("refused".to_string());
        assert_eq!(err.to_string(), "Connection failed: refused");

        let err = BlockchainError::RpcError("invalid method".to_string());
        assert_eq!(err.to_string(), "RPC call failed: invalid method");

        let err = BlockchainError::TransactionFailed("nonce".to_string());
        assert_eq!(err.to_string(), "Transaction failed: nonce");

        let err = BlockchainError::InvalidSignature("corrupt".to_string());
        assert_eq!(err.to_string(), "Invalid signature: corrupt");

        let err = BlockchainError::InsufficientFunds;
        assert_eq!(err.to_string(), "Insufficient funds for transaction");

        let err = BlockchainError::Timeout("30s".to_string());
        assert_eq!(err.to_string(), "Timeout waiting for confirmation: 30s");
    }

    #[test]
    fn test_config_error_display() {
        let err = ConfigError::MissingEnvVar("DATABASE_URL".to_string());
        assert_eq!(
            err.to_string(),
            "Missing environment variable: DATABASE_URL"
        );

        let err = ConfigError::InvalidValue {
            key: "PORT".to_string(),
            message: "not a number".to_string(),
        };
        assert_eq!(err.to_string(), "Invalid value for 'PORT': not a number");

        let err = ConfigError::ParseError("json parse".to_string());
        assert_eq!(err.to_string(), "Parse error: json parse");
    }

    #[test]
    fn test_validation_error_display() {
        let err = ValidationError::InvalidField {
            field: "email".to_string(),
            message: "invalid format".to_string(),
        };
        assert_eq!(err.to_string(), "Invalid field 'email': invalid format");

        let err = ValidationError::MissingField("name".to_string());
        assert_eq!(err.to_string(), "Missing required field: name");

        let err = ValidationError::InvalidFormat("date".to_string());
        assert_eq!(err.to_string(), "Invalid format: date");

        let err = ValidationError::Multiple("many errors".to_string());
        assert_eq!(err.to_string(), "Validation failed: many errors");
    }

    #[test]
    fn test_external_service_error_display() {
        let err = ExternalServiceError::HttpError("404".to_string());
        assert_eq!(err.to_string(), "HTTP request failed: 404");

        let err = ExternalServiceError::Unavailable("payment gateway".to_string());
        assert_eq!(err.to_string(), "Service unavailable: payment gateway");

        let err = ExternalServiceError::Timeout("30s".to_string());
        assert_eq!(err.to_string(), "Timeout: 30s");

        let err = ExternalServiceError::RateLimited("api".to_string());
        assert_eq!(err.to_string(), "Rate limited: api");
    }

    #[test]
    fn test_app_error_display() {
        let err = AppError::Authentication("bad token".to_string());
        assert_eq!(err.to_string(), "Authentication failed: bad token");

        let err = AppError::Authorization("no access".to_string());
        assert_eq!(err.to_string(), "Authorization denied: no access");

        let err = AppError::Serialization("json".to_string());
        assert_eq!(err.to_string(), "Serialization error: json");

        let err = AppError::Deserialization("yaml".to_string());
        assert_eq!(err.to_string(), "Deserialization error: yaml");

        let err = AppError::Internal("panic".to_string());
        assert_eq!(err.to_string(), "Internal error: panic");

        let err = AppError::NotSupported("feature".to_string());
        assert_eq!(err.to_string(), "Operation not supported: feature");

        let err = AppError::RateLimited;
        assert_eq!(err.to_string(), "Rate limit exceeded");
    }

    #[test]
    fn test_app_error_from_database_error() {
        let db_err = DatabaseError::NotFound("id".to_string());
        let app_err: AppError = db_err.into();
        assert!(matches!(
            app_err,
            AppError::Database(DatabaseError::NotFound(_))
        ));
    }

    #[test]
    fn test_app_error_from_blockchain_error() {
        let bc_err = BlockchainError::Timeout("10s".to_string());
        let app_err: AppError = bc_err.into();
        assert!(matches!(
            app_err,
            AppError::Blockchain(BlockchainError::Timeout(_))
        ));
    }

    #[test]
    fn test_app_error_from_external_service_error() {
        let ext_err = ExternalServiceError::Unavailable("api".to_string());
        let app_err: AppError = ext_err.into();
        assert!(matches!(
            app_err,
            AppError::ExternalService(ExternalServiceError::Unavailable(_))
        ));
    }

    #[test]
    fn test_app_error_from_config_error() {
        let cfg_err = ConfigError::MissingEnvVar("KEY".to_string());
        let app_err: AppError = cfg_err.into();
        assert!(matches!(
            app_err,
            AppError::Config(ConfigError::MissingEnvVar(_))
        ));
    }

    #[test]
    fn test_app_error_from_validation_error() {
        let val_err = ValidationError::MissingField("email".to_string());
        let app_err: AppError = val_err.into();
        assert!(matches!(
            app_err,
            AppError::Validation(ValidationError::MissingField(_))
        ));
    }

    #[test]
    fn test_app_error_from_migrate_error() {
        // Construct a simple MigrateError.
        // MigrateError::VersionMissing(1) is easy to construct.
        let mig_err = sqlx::migrate::MigrateError::VersionMissing(1);
        let app_err: AppError = mig_err.into();

        match app_err {
            AppError::Database(DatabaseError::Migration(msg)) => {
                assert!(msg.contains("migration 1 was previously applied"));
            }
            _ => panic!("Expected DatabaseError::Migration, got {:?}", app_err),
        }
    }
}

===== ./domain/mod.rs =====
//! Domain layer containing core business types, traits, and error definitions.

pub mod error;
pub mod traits;
pub mod types;

pub use error::{
    AppError, BlockchainError, ConfigError, DatabaseError, ExternalServiceError, ValidationError,
};
pub use traits::{BlockchainClient, ComplianceProvider, DatabaseClient};
pub use types::{
    BlockchainStatus, ComplianceStatus, ErrorDetail, ErrorResponse, HealthResponse, HealthStatus,
    HeliusTransaction, PaginatedResponse, PaginationParams, RateLimitResponse,
    SubmitTransferRequest, TransferRequest, TransferType,
};

===== ./domain/traits.rs =====
//! Domain traits defining contracts for external systems.

use async_trait::async_trait;

use super::error::AppError;
use super::types::{
    BlockchainStatus, ComplianceStatus, PaginatedResponse, SubmitTransferRequest, TransferRequest,
};
use chrono::{DateTime, Utc};

/// Compliance provider trait for screening requests
#[async_trait]
pub trait ComplianceProvider: Send + Sync {
    /// Check if a transfer request is compliant
    async fn check_compliance(
        &self,
        request: &SubmitTransferRequest,
    ) -> Result<ComplianceStatus, AppError>;
}

/// Database client trait for persistence operations
#[async_trait]
pub trait DatabaseClient: Send + Sync {
    /// Check database connectivity
    async fn health_check(&self) -> Result<(), AppError>;

    /// Get a single transfer request by ID
    async fn get_transfer_request(&self, id: &str) -> Result<Option<TransferRequest>, AppError>;

    /// Submit a new transfer request
    async fn submit_transfer(
        &self,
        data: &SubmitTransferRequest,
    ) -> Result<TransferRequest, AppError>;

    /// List transfer requests with cursor-based pagination
    async fn list_transfer_requests(
        &self,
        limit: i64,
        cursor: Option<&str>,
    ) -> Result<PaginatedResponse<TransferRequest>, AppError>;

    /// Update blockchain status for a transfer request
    async fn update_blockchain_status(
        &self,
        id: &str,
        status: BlockchainStatus,
        signature: Option<&str>,
        error: Option<&str>,
        next_retry_at: Option<DateTime<Utc>>,
    ) -> Result<(), AppError>;

    /// Update compliance status for a transfer request
    async fn update_compliance_status(
        &self,
        id: &str,
        status: crate::domain::ComplianceStatus,
    ) -> Result<(), AppError>;

    /// Get requests pending blockchain submission
    async fn get_pending_blockchain_requests(
        &self,
        limit: i64,
    ) -> Result<Vec<TransferRequest>, AppError>;

    /// Increment retry count for a request
    async fn increment_retry_count(&self, id: &str) -> Result<i32, AppError>;

    /// Get a transfer request by blockchain signature
    async fn get_transfer_by_signature(
        &self,
        signature: &str,
    ) -> Result<Option<TransferRequest>, AppError>;
}

/// Blockchain client trait for chain operations
#[async_trait]
pub trait BlockchainClient: Send + Sync {
    /// Check blockchain RPC connectivity
    async fn health_check(&self) -> Result<(), AppError>;

    /// Submit a transaction using the transfer request details
    async fn submit_transaction(&self, request: &TransferRequest) -> Result<String, AppError>;

    /// Get transaction confirmation status
    async fn get_transaction_status(&self, signature: &str) -> Result<bool, AppError> {
        let _ = signature;
        Err(AppError::NotSupported(
            "get_transaction_status not implemented".to_string(),
        ))
    }

    /// Get current block height
    async fn get_block_height(&self) -> Result<u64, AppError> {
        Err(AppError::NotSupported(
            "get_block_height not implemented".to_string(),
        ))
    }

    /// Get latest blockhash for transaction construction
    async fn get_latest_blockhash(&self) -> Result<String, AppError> {
        Err(AppError::NotSupported(
            "get_latest_blockhash not implemented".to_string(),
        ))
    }

    /// Wait for transaction confirmation with timeout
    async fn wait_for_confirmation(
        &self,
        signature: &str,
        timeout_secs: u64,
    ) -> Result<bool, AppError> {
        let _ = (signature, timeout_secs);
        Err(AppError::NotSupported(
            "wait_for_confirmation not implemented".to_string(),
        ))
    }

    /// Transfer SOL from the issuer wallet to a destination address
    /// Amount is in lamports (1 SOL = 1_000_000_000 lamports)
    /// Returns the transaction signature on success
    async fn transfer_sol(
        &self,
        to_address: &str,
        amount_lamports: u64,
    ) -> Result<String, AppError> {
        let _ = (to_address, amount_lamports);
        Err(AppError::NotSupported(
            "transfer_sol not implemented".to_string(),
        ))
    }

    /// Transfer SPL Tokens from the issuer wallet to a destination address
    /// Creates the destination ATA if it doesn't exist
    /// Amount is in raw token units (caller must pre-convert using token decimals)
    /// Example: 1 USDC (6 decimals) = 1_000_000 raw units
    /// Returns the transaction signature on success
    async fn transfer_token(
        &self,
        to_address: &str,
        token_mint: &str,
        amount: u64,
    ) -> Result<String, AppError> {
        let _ = (to_address, token_mint, amount);
        Err(AppError::NotSupported(
            "transfer_token not implemented".to_string(),
        ))
    }

    /// Transfer Token-2022 Confidential tokens
    /// The server constructs the instruction from structured proof components,
    /// ensuring full control over what it signs (mitigates Confused Deputy).
    async fn transfer_confidential(
        &self,
        to_address: &str,
        token_mint: &str,
        new_decryptable_available_balance: &str,
        equality_proof: &str,
        ciphertext_validity_proof: &str,
        range_proof: &str,
    ) -> Result<String, AppError> {
        let _ = (
            to_address,
            token_mint,
            new_decryptable_available_balance,
            equality_proof,
            ciphertext_validity_proof,
            range_proof,
        );
        Err(AppError::NotSupported(
            "transfer_confidential not implemented".to_string(),
        ))
    }

    /// Check if a wallet holds compliant assets using DAS (Digital Asset Standard).
    /// This is a Helius-specific feature for compliance screening.
    ///
    /// Returns `false` if the wallet holds assets from sanctioned collections.
    /// For non-Helius providers, returns `true` (skip check / assume compliant).
    ///
    /// # Arguments
    /// * `owner` - The wallet address (Base58) to check
    async fn check_wallet_assets(&self, owner: &str) -> Result<bool, AppError> {
        let _ = owner;
        // Default: skip check for providers without DAS support
        Ok(true)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Minimal implementation for testing default methods
    #[allow(dead_code)]
    struct MinimalDatabaseClient;

    #[async_trait]
    impl DatabaseClient for MinimalDatabaseClient {
        async fn health_check(&self) -> Result<(), AppError> {
            Ok(())
        }

        async fn get_transfer_request(
            &self,
            _id: &str,
        ) -> Result<Option<TransferRequest>, AppError> {
            Ok(None)
        }

        async fn submit_transfer(
            &self,
            _data: &SubmitTransferRequest,
        ) -> Result<TransferRequest, AppError> {
            Ok(TransferRequest::default())
        }

        async fn list_transfer_requests(
            &self,
            _limit: i64,
            _cursor: Option<&str>,
        ) -> Result<PaginatedResponse<TransferRequest>, AppError> {
            Ok(PaginatedResponse::empty())
        }

        async fn update_blockchain_status(
            &self,
            _id: &str,
            _status: BlockchainStatus,
            _signature: Option<&str>,
            _error: Option<&str>,
            _next_retry_at: Option<DateTime<Utc>>,
        ) -> Result<(), AppError> {
            Ok(())
        }

        async fn update_compliance_status(
            &self,
            _id: &str,
            _status: crate::domain::ComplianceStatus,
        ) -> Result<(), AppError> {
            Ok(())
        }

        async fn get_pending_blockchain_requests(
            &self,
            _limit: i64,
        ) -> Result<Vec<TransferRequest>, AppError> {
            Ok(vec![])
        }

        async fn increment_retry_count(&self, _id: &str) -> Result<i32, AppError> {
            Ok(1)
        }

        async fn get_transfer_by_signature(
            &self,
            _signature: &str,
        ) -> Result<Option<TransferRequest>, AppError> {
            Ok(None)
        }
    }

    struct MinimalBlockchainClient;

    #[async_trait]
    impl BlockchainClient for MinimalBlockchainClient {
        async fn health_check(&self) -> Result<(), AppError> {
            Ok(())
        }

        async fn submit_transaction(&self, _request: &TransferRequest) -> Result<String, AppError> {
            Ok("sig_123".to_string())
        }
    }

    #[tokio::test]
    async fn test_blockchain_client_get_transaction_status_not_supported() {
        let client = MinimalBlockchainClient;
        let result = client.get_transaction_status("sig").await;
        assert!(matches!(result, Err(AppError::NotSupported(_))));
    }
}

===== ./domain/types.rs =====
//! Domain types with validation support.

use chrono::{DateTime, Utc};
use ed25519_dalek::{Signature, VerifyingKey};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;
use validator::Validate;

use crate::domain::AppError;

/// Status of blockchain submission for a transfer
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default, ToSchema)]
#[serde(rename_all = "snake_case")]
pub enum BlockchainStatus {
    /// Initial state, not yet processed
    #[default]
    Pending,
    /// Waiting to be submitted to blockchain (queued for worker)
    PendingSubmission,
    /// Worker has claimed this task, processing in progress
    Processing,
    /// Transaction submitted, awaiting confirmation
    Submitted,
    /// Transaction confirmed on blockchain
    Confirmed,
    /// Submission failed after max retries
    Failed,
}

impl BlockchainStatus {
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Pending => "pending",
            Self::PendingSubmission => "pending_submission",
            Self::Processing => "processing",
            Self::Submitted => "submitted",
            Self::Confirmed => "confirmed",
            Self::Failed => "failed",
        }
    }
}

impl std::str::FromStr for BlockchainStatus {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "pending" => Ok(Self::Pending),
            "pending_submission" => Ok(Self::PendingSubmission),
            "processing" => Ok(Self::Processing),
            "submitted" => Ok(Self::Submitted),
            "confirmed" => Ok(Self::Confirmed),
            "failed" => Ok(Self::Failed),
            _ => Err(format!("Invalid blockchain status: {}", s)),
        }
    }
}

impl std::fmt::Display for BlockchainStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

/// Compliance status for a transfer
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Default, ToSchema)]
#[serde(rename_all = "snake_case")]
pub enum ComplianceStatus {
    /// Initial state, waiting for compliance check
    #[default]
    Pending,
    /// Compliance check passed
    Approved,
    /// Compliance check failed
    Rejected,
}

impl ComplianceStatus {
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Pending => "pending",
            Self::Approved => "approved",
            Self::Rejected => "rejected",
        }
    }
}

impl std::str::FromStr for ComplianceStatus {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "pending" => Ok(Self::Pending),
            "approved" => Ok(Self::Approved),
            "rejected" => Ok(Self::Rejected),
            _ => Err(format!("Invalid compliance status: {}", s)),
        }
    }
}

impl std::fmt::Display for ComplianceStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

/// Type of transfer and associated data
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum TransferType {
    /// Standard public transfer with visible amount
    Public {
        /// Amount in atomic units
        #[schema(example = 1_000_000_000)]
        amount: u64,
    },
    /// Confidential transfer with zero-knowledge proofs (Token-2022)
    ///
    /// The client must generate all ZK proofs locally and submit the individual
    /// proof components. The server constructs the instruction from these
    /// components, ensuring it maintains full control over what it signs.
    Confidential {
        /// New source decryptable available balance after transfer (Base64 AES ciphertext)
        /// This is the encrypted balance that only the source account holder can decrypt
        #[schema(example = "SGVsbG8gV29ybGQ=")]
        new_decryptable_available_balance: String,

        /// Equality proof (Base64 serialized CiphertextCommitmentEqualityProofData)
        /// Proves that the new balance ciphertext correctly results from subtracting
        /// the transfer amount from the current balance
        #[schema(example = "SGVsbG8gRXF1YWxpdHkgUHJvb2Y=")]
        equality_proof: String,

        /// Ciphertext validity proof (Base64 serialized BatchedGroupedCiphertext3HandlesValidityProofData)
        /// Proves that the transfer amount ciphertexts are correctly constructed for
        /// source, destination, and optional auditor
        #[schema(example = "SGVsbG8gVmFsaWRpdHkgUHJvb2Y=")]
        ciphertext_validity_proof: String,

        /// Range proof (Base64 serialized BatchedRangeProofU128Data)
        /// Proves that the new balance and transfer amount are non-negative
        /// and within valid range
        #[schema(example = "SGVsbG8gUmFuZ2UgUHJvb2Y=")]
        range_proof: String,
    },
}

/// Core transfer request entity
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
pub struct TransferRequest {
    /// Unique identifier (UUID)
    #[schema(example = "550e8400-e29b-41d4-a716-446655440000")]
    pub id: String,
    /// Sender wallet address (Base58 Solana address)
    #[schema(example = "HvwC9QSAzwEXkUkwqNNGhfNHoVqXJYfPvPZfQvJmHWcF")]
    pub from_address: String,
    /// Recipient wallet address (Base58 Solana address)
    #[schema(example = "DRpbCBMxVnDK7maPM5tGv6MvB3v1sRMC86PZ8okm21hy")]
    pub to_address: String,

    /// Transfer details (Public vs Confidential)
    pub transfer_details: TransferType,

    /// Optional SPL Token mint address. None means native SOL transfer.
    #[schema(example = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v")]
    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub token_mint: Option<String>,

    /// Compliance check status
    pub compliance_status: ComplianceStatus,
    /// Blockchain submission status
    pub blockchain_status: BlockchainStatus,
    /// Blockchain transaction signature (if submitted)
    #[schema(example = "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d")]
    pub blockchain_signature: Option<String>,
    /// Number of retry attempts for blockchain submission
    pub blockchain_retry_count: i32,
    /// Last error message from blockchain submission
    pub blockchain_last_error: Option<String>,
    /// Next scheduled retry time
    pub blockchain_next_retry_at: Option<DateTime<Utc>>,
    /// Creation timestamp
    pub created_at: DateTime<Utc>,
    /// Last update timestamp
    pub updated_at: DateTime<Utc>,
}

impl TransferRequest {
    #[must_use]
    pub fn new(id: String, from_address: String, to_address: String, amount: u64) -> Self {
        let now = Utc::now();
        Self {
            id,
            from_address,
            to_address,
            transfer_details: TransferType::Public { amount },
            token_mint: None,
            compliance_status: ComplianceStatus::Pending,
            blockchain_status: BlockchainStatus::Pending,
            blockchain_signature: None,
            blockchain_retry_count: 0,
            blockchain_last_error: None,
            blockchain_next_retry_at: None,
            created_at: now,
            updated_at: now,
        }
    }

    /// Create a new token transfer request
    #[must_use]
    pub fn new_token(
        id: String,
        from_address: String,
        to_address: String,
        amount: u64,
        token_mint: String,
    ) -> Self {
        let mut request = Self::new(id, from_address, to_address, amount);
        request.token_mint = Some(token_mint);
        request
    }

    /// Check if this is an SPL Token transfer
    #[must_use]
    pub fn is_token_transfer(&self) -> bool {
        self.token_mint.is_some()
    }
}

impl Default for TransferRequest {
    fn default() -> Self {
        Self::new(
            "default_id".to_string(),
            "default_from".to_string(),
            "default_to".to_string(),
            0,
        )
    }
}

/// Request to submit a new transfer
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct SubmitTransferRequest {
    /// Sender wallet address (Base58 Solana address)
    #[schema(example = "HvwC9QSAzwEXkUkwqNNGhfNHoVqXJYfPvPZfQvJmHWcF")]
    pub from_address: String,
    /// Recipient wallet address (Base58 Solana address)
    #[schema(example = "DRpbCBMxVnDK7maPM5tGv6MvB3v1sRMC86PZ8okm21hy")]
    pub to_address: String,

    /// Transfer details (Public or Confidential)
    pub transfer_details: TransferType,

    /// Optional SPL Token mint address. If None, this is a native SOL transfer.
    /// If Some, this is an SPL Token transfer for the specified mint.
    #[schema(example = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v")]
    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub token_mint: Option<String>,

    /// Base58-encoded Ed25519 signature proving ownership of from_address.
    /// The message format is: "{from_address}:{to_address}:{amount|confidential}:{token_mint|SOL}"
    #[schema(
        example = "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d"
    )]
    pub signature: String,
}

impl Validate for SubmitTransferRequest {
    fn validate(&self) -> Result<(), validator::ValidationErrors> {
        let mut errors = validator::ValidationErrors::new();

        if self.from_address.is_empty() {
            errors.add(
                "from_address",
                validator::ValidationError::new("From address is required"),
            );
        }
        if self.to_address.is_empty() {
            errors.add(
                "to_address",
                validator::ValidationError::new("To address is required"),
            );
        }

        match &self.transfer_details {
            TransferType::Public { amount } => {
                if *amount == 0 {
                    errors.add(
                        "amount",
                        validator::ValidationError::new("Amount must be greater than 0"),
                    );
                }
            }
            TransferType::Confidential {
                new_decryptable_available_balance,
                equality_proof,
                ciphertext_validity_proof,
                range_proof,
            } => {
                if new_decryptable_available_balance.is_empty() {
                    errors.add(
                        "new_decryptable_available_balance",
                        validator::ValidationError::new(
                            "New decryptable available balance is required for confidential transfers",
                        ),
                    );
                }
                if equality_proof.is_empty() {
                    errors.add(
                        "equality_proof",
                        validator::ValidationError::new(
                            "Equality proof is required for confidential transfers",
                        ),
                    );
                }
                if ciphertext_validity_proof.is_empty() {
                    errors.add(
                        "ciphertext_validity_proof",
                        validator::ValidationError::new(
                            "Ciphertext validity proof is required for confidential transfers",
                        ),
                    );
                }
                if range_proof.is_empty() {
                    errors.add(
                        "range_proof",
                        validator::ValidationError::new(
                            "Range proof is required for confidential transfers",
                        ),
                    );
                }
            }
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

impl SubmitTransferRequest {
    /// Verify that the signature is valid for this request.
    /// Returns Ok(()) if valid, or AppError::Authorization if invalid.
    pub fn verify_signature(&self) -> Result<(), AppError> {
        // Construct the deterministic message to verify
        let message = self.create_signing_message();

        // Decode the from_address as a Solana public key (32 bytes)
        let pubkey_bytes = bs58::decode(&self.from_address).into_vec().map_err(|e| {
            AppError::Authorization(format!("Invalid from_address encoding: {}", e))
        })?;

        if pubkey_bytes.len() != 32 {
            return Err(AppError::Authorization(format!(
                "Invalid from_address length: expected 32 bytes, got {}",
                pubkey_bytes.len()
            )));
        }

        let pubkey_array: [u8; 32] = pubkey_bytes
            .try_into()
            .map_err(|_| AppError::Authorization("Invalid from_address format".to_string()))?;

        let verifying_key = VerifyingKey::from_bytes(&pubkey_array)
            .map_err(|e| AppError::Authorization(format!("Invalid public key: {}", e)))?;

        // Decode the signature (64 bytes)
        let sig_bytes = bs58::decode(&self.signature)
            .into_vec()
            .map_err(|e| AppError::Authorization(format!("Invalid signature encoding: {}", e)))?;

        if sig_bytes.len() != 64 {
            return Err(AppError::Authorization(format!(
                "Invalid signature length: expected 64 bytes, got {}",
                sig_bytes.len()
            )));
        }

        let sig_array: [u8; 64] = sig_bytes
            .try_into()
            .map_err(|_| AppError::Authorization("Invalid signature format".to_string()))?;

        let signature = Signature::from_bytes(&sig_array);

        // Verify the signature
        verifying_key
            .verify_strict(&message, &signature)
            .map_err(|e| {
                AppError::Authorization(format!("Signature verification failed: {}", e))
            })?;

        Ok(())
    }

    /// Create the deterministic message for signing.
    /// Format: "{from_address}:{to_address}:{amount|confidential}:{token_mint|SOL}"
    #[must_use]
    pub fn create_signing_message(&self) -> Vec<u8> {
        let amount_part = match &self.transfer_details {
            TransferType::Public { amount } => amount.to_string(),
            TransferType::Confidential { .. } => "confidential".to_string(),
        };
        let mint_part = self.token_mint.as_deref().unwrap_or("SOL");
        format!(
            "{}:{}:{}:{}",
            self.from_address, self.to_address, amount_part, mint_part
        )
        .into_bytes()
    }

    #[must_use]
    pub fn new(from_address: String, to_address: String, amount: u64, signature: String) -> Self {
        Self {
            from_address,
            to_address,
            transfer_details: TransferType::Public { amount },
            token_mint: None,
            signature,
        }
    }

    /// Create a new SPL Token transfer request
    #[must_use]
    pub fn new_token_transfer(
        from_address: String,
        to_address: String,
        amount: u64,
        token_mint: String,
        signature: String,
    ) -> Self {
        Self {
            from_address,
            to_address,
            transfer_details: TransferType::Public { amount },
            token_mint: Some(token_mint),
            signature,
        }
    }

    /// Create a new Confidential transfer request
    #[must_use]
    #[allow(clippy::too_many_arguments)]
    pub fn new_confidential(
        from_address: String,
        to_address: String,
        new_decryptable_available_balance: String,
        equality_proof: String,
        ciphertext_validity_proof: String,
        range_proof: String,
        token_mint: String,
        signature: String,
    ) -> Self {
        Self {
            from_address,
            to_address,
            transfer_details: TransferType::Confidential {
                new_decryptable_available_balance,
                equality_proof,
                ciphertext_validity_proof,
                range_proof,
            },
            token_mint: Some(token_mint),
            signature,
        }
    }

    /// Check if this is an SPL Token transfer
    #[must_use]
    pub fn is_token_transfer(&self) -> bool {
        self.token_mint.is_some()
    }
}

/// Pagination parameters for list requests
#[derive(Debug, Clone, Serialize, Deserialize, Validate, ToSchema)]
pub struct PaginationParams {
    /// Maximum number of items to return (1-100, default: 20)
    #[validate(range(min = 1, max = 100, message = "Limit must be between 1 and 100"))]
    #[serde(default = "default_limit")]
    #[schema(example = 20)]
    pub limit: i64,
    /// Cursor for pagination (ID to start after)
    #[schema(example = "uuid-string")]
    pub cursor: Option<String>,
}

fn default_limit() -> i64 {
    20
}

impl Default for PaginationParams {
    fn default() -> Self {
        Self {
            limit: default_limit(),
            cursor: None,
        }
    }
}

/// Paginated response wrapper
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct PaginatedResponse<T: ToSchema> {
    /// List of items
    pub items: Vec<T>,
    /// Cursor for next page (null if no more items)
    #[schema(example = "uuid-string")]
    pub next_cursor: Option<String>,
    /// Whether more items exist
    pub has_more: bool,
}

impl<T: ToSchema> PaginatedResponse<T> {
    pub fn new(items: Vec<T>, next_cursor: Option<String>, has_more: bool) -> Self {
        Self {
            items,
            next_cursor,
            has_more,
        }
    }

    pub fn empty() -> Self {
        Self {
            items: Vec::new(),
            next_cursor: None,
            has_more: false,
        }
    }
}

/// Health status enum
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, ToSchema)]
#[serde(rename_all = "lowercase")]
pub enum HealthStatus {
    /// All systems operational
    Healthy,
    /// Some systems degraded but functional
    Degraded,
    /// Critical systems unavailable
    Unhealthy,
}

/// Health check response
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct HealthResponse {
    /// Overall system status
    pub status: HealthStatus,
    /// Database health status
    pub database: HealthStatus,
    /// Blockchain client health status
    pub blockchain: HealthStatus,
    /// Current server timestamp
    pub timestamp: DateTime<Utc>,
    /// Application version
    #[schema(example = "0.3.0")]
    pub version: String,
}

impl HealthResponse {
    #[must_use]
    pub fn new(database: HealthStatus, blockchain: HealthStatus) -> Self {
        let status = match (&database, &blockchain) {
            (HealthStatus::Healthy, HealthStatus::Healthy) => HealthStatus::Healthy,
            (HealthStatus::Unhealthy, _) | (_, HealthStatus::Unhealthy) => HealthStatus::Unhealthy,
            _ => HealthStatus::Degraded,
        };
        Self {
            status,
            database,
            blockchain,
            timestamp: Utc::now(),
            version: env!("CARGO_PKG_VERSION").to_string(),
        }
    }
}

/// Error response structure
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct ErrorResponse {
    /// Error details
    pub error: ErrorDetail,
}

/// Error detail structure
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct ErrorDetail {
    /// Error type identifier
    #[schema(example = "validation_error")]
    pub r#type: String,
    /// Human-readable error message
    #[schema(example = "Name must be between 1 and 255 characters")]
    pub message: String,
}

/// Rate limit exceeded response
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct RateLimitResponse {
    /// Error details
    pub error: ErrorDetail,
    /// Seconds until rate limit resets
    #[schema(example = 60)]
    pub retry_after: u64,
}

/// Single transaction from Helius webhook (Enhanced Transaction format)
/// Reference: <https://docs.helius.dev/webhooks-and-websockets/webhooks>
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct HeliusTransaction {
    /// Transaction type (e.g., "TRANSFER", "NFT_SALE", "UNKNOWN")
    #[serde(rename = "type")]
    pub transaction_type: String,
    /// Transaction signature (base58)
    pub signature: String,
    /// Transaction error (null if successful, object/string if failed)
    #[serde(default)]
    pub transaction_error: Option<serde_json::Value>,
    /// Source program (e.g., "SYSTEM_PROGRAM")
    #[serde(default)]
    pub source: String,
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    #[test]
    fn test_blockchain_status_display_and_parsing() {
        let statuses = vec![
            (BlockchainStatus::Pending, "pending"),
            (BlockchainStatus::PendingSubmission, "pending_submission"),
            (BlockchainStatus::Submitted, "submitted"),
            (BlockchainStatus::Confirmed, "confirmed"),
            (BlockchainStatus::Failed, "failed"),
        ];

        for (status, string) in statuses {
            assert_eq!(status.as_str(), string);
            assert_eq!(status.to_string(), string);
            assert_eq!(BlockchainStatus::from_str(string).unwrap(), status);
        }

        assert!(BlockchainStatus::from_str("invalid").is_err());
    }

    #[test]
    fn test_compliance_status_display_and_parsing() {
        let statuses = vec![
            (ComplianceStatus::Pending, "pending"),
            (ComplianceStatus::Approved, "approved"),
            (ComplianceStatus::Rejected, "rejected"),
        ];

        for (status, string) in statuses {
            assert_eq!(status.as_str(), string);
            assert_eq!(status.to_string(), string);
            assert_eq!(ComplianceStatus::from_str(string).unwrap(), status);
        }

        assert!(ComplianceStatus::from_str("invalid").is_err());
    }

    #[test]
    fn test_submit_transfer_request_validation() {
        // Valid request (1 SOL in lamports)
        let req = SubmitTransferRequest::new(
            "From".to_string(),
            "To".to_string(),
            1_000_000_000,
            "sig".to_string(),
        );
        assert!(req.validate().is_ok());

        // Invalid From (empty)
        let req = SubmitTransferRequest::new(
            "".to_string(),
            "To".to_string(),
            1_000_000_000,
            "sig".to_string(),
        );
        assert!(req.validate().is_err());

        // Invalid To (empty)
        let req = SubmitTransferRequest::new(
            "From".to_string(),
            "".to_string(),
            1_000_000_000,
            "sig".to_string(),
        );
        assert!(req.validate().is_err());

        // Invalid Amount (zero)
        let req =
            SubmitTransferRequest::new("From".to_string(), "To".to_string(), 0, "sig".to_string());
        assert!(req.validate().is_err());

        // Valid Confidential Request
        let req = SubmitTransferRequest::new_confidential(
            "From".to_string(),
            "To".to_string(),
            "balance".to_string(),
            "equality".to_string(),
            "validity".to_string(),
            "range".to_string(),
            "mint".to_string(),
            "sig".to_string(),
        );
        assert!(req.validate().is_ok());

        // Invalid Confidential (empty equality proof)
        let req = SubmitTransferRequest::new_confidential(
            "From".to_string(),
            "To".to_string(),
            "balance".to_string(),
            "".to_string(),
            "validity".to_string(),
            "range".to_string(),
            "mint".to_string(),
            "sig".to_string(),
        );
        assert!(req.validate().is_err());
    }

    #[test]
    fn test_transfer_request_initialization_defaults() {
        let req = TransferRequest::new(
            "id_123".to_string(),
            "from_123".to_string(),
            "to_123".to_string(),
            10_500_000_000, // 10.5 SOL in lamports
        );

        assert_eq!(req.compliance_status, ComplianceStatus::Pending);
        assert_eq!(req.blockchain_status, BlockchainStatus::Pending);
        assert!(req.blockchain_signature.is_none());
        assert_eq!(req.blockchain_retry_count, 0);
        assert!(req.blockchain_last_error.is_none());
        assert!(req.blockchain_next_retry_at.is_none());
        assert_eq!(
            req.transfer_details,
            TransferType::Public {
                amount: 10_500_000_000
            }
        );
    }

    #[test]
    fn test_transfer_request_serialization_roundtrip() {
        let req = TransferRequest::new(
            "tr_123".to_string(),
            "from_abc".to_string(),
            "to_xyz".to_string(),
            5_000_000_000, // 5 SOL in lamports
        );

        let json = serde_json::to_string(&req).unwrap();
        let deserialized: TransferRequest = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.id, "tr_123");
        assert_eq!(deserialized.from_address, "from_abc");
        assert_eq!(deserialized.to_address, "to_xyz");
        assert_eq!(
            deserialized.transfer_details,
            TransferType::Public {
                amount: 5_000_000_000
            }
        );
    }
}

===== ./infra/blockchain/helius.rs =====
//! Helius RPC provider integration.
//!
//! Implements Helius-specific features:
//! - Priority Fee Estimation via `getPriorityFeeEstimate`
//! - Digital Asset Standard (DAS) API for compliance checks
//! - Smart Transaction submission (future enhancement)
//!
//! # Usage
//! The Helius features are auto-activated when the RPC URL contains `helius-rpc.com`
//! or when `HELIUS_API_KEY` environment variable is set.

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use tracing::{debug, info, warn};

use crate::domain::{AppError, BlockchainError};

use super::strategies::FeeStrategy;

// ============================================================================
// SANCTIONED COLLECTIONS (Mock for Hackathon)
// ============================================================================

/// Sanctioned collection addresses
///
/// In production, this would be fetched from a compliance oracle or database.
/// For the hackathon demo, we use a static list of mock addresses.
pub const SANCTIONED_COLLECTIONS: &[&str] = &[
    // Mock sanctioned collection addresses for demo
    "SANCTIONED111111111111111111111111111111111",
    "SANCTIONED222222222222222222222222222222222",
    // Add known malicious NFT collections here
    "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263", // Example: Known scam collection
];

// ============================================================================
// HELIUS FEE STRATEGY
// ============================================================================

/// Helius Priority Fee Response
#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct HeliusPriorityFeeResponse {
    pub priority_fee_estimate: Option<f64>,
    #[allow(dead_code)]
    pub priority_fee_levels: Option<HeliusPriorityFeeLevels>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct HeliusPriorityFeeLevels {
    #[allow(dead_code)]
    pub min: Option<f64>,
    #[allow(dead_code)]
    pub low: Option<f64>,
    pub medium: Option<f64>,
    pub high: Option<f64>,
    #[allow(dead_code)]
    pub very_high: Option<f64>,
    #[allow(dead_code)]
    pub unsafe_max: Option<f64>,
}

/// Helius-specific fee strategy using `getPriorityFeeEstimate`
///
/// This strategy provides more accurate fee estimates by analyzing the
/// accounts involved in the transaction.
pub struct HeliusFeeStrategy {
    rpc_url: String,
    http_client: reqwest::Client,
    default_fee: u64,
}

impl HeliusFeeStrategy {
    pub fn new(rpc_url: &str) -> Self {
        info!("Helius Priority Fee Strategy activated!");
        Self {
            rpc_url: rpc_url.to_string(),
            http_client: reqwest::Client::new(),
            default_fee: 100,
        }
    }
}

#[derive(Debug, Serialize)]
struct JsonRpcRequest<T: Serialize> {
    jsonrpc: &'static str,
    id: &'static str,
    method: String,
    params: T,
}

#[derive(Debug, Deserialize)]
struct JsonRpcResponse<T> {
    result: Option<T>,
    error: Option<JsonRpcError>,
}

#[derive(Debug, Deserialize)]
struct JsonRpcError {
    #[allow(dead_code)]
    code: i64,
    message: String,
}

#[async_trait]
impl FeeStrategy for HeliusFeeStrategy {
    async fn get_priority_fee(&self, serialized_tx: Option<&str>) -> u64 {
        // Build params based on whether we have a transaction
        let params = if let Some(tx) = serialized_tx {
            serde_json::json!({
                "transaction": tx,
                "options": {
                    "includeAllPriorityFeeLevels": true
                }
            })
        } else {
            // Without a transaction, request global estimate
            serde_json::json!({
                "options": {
                    "includeAllPriorityFeeLevels": true
                }
            })
        };

        let request = JsonRpcRequest {
            jsonrpc: "2.0",
            id: "helius-fee",
            method: "getPriorityFeeEstimate".to_string(),
            params: vec![params],
        };

        match self
            .http_client
            .post(&self.rpc_url)
            .json(&request)
            .send()
            .await
        {
            Ok(response) => {
                match response
                    .json::<JsonRpcResponse<HeliusPriorityFeeResponse>>()
                    .await
                {
                    Ok(rpc_response) => {
                        if let Some(error) = rpc_response.error {
                            debug!(error = %error.message, "Helius fee API error, using default");
                            return self.default_fee;
                        }

                        if let Some(result) = rpc_response.result {
                            // Prefer the direct estimate, fall back to levels
                            let fee = result
                                .priority_fee_estimate
                                .or_else(|| {
                                    result.priority_fee_levels.as_ref().and_then(|l| l.high)
                                })
                                .or_else(|| {
                                    result.priority_fee_levels.as_ref().and_then(|l| l.medium)
                                })
                                .unwrap_or(self.default_fee as f64);

                            let fee_u64 = fee as u64;
                            info!(
                                priority_fee = %fee_u64,
                                "Helius priority fee applied (micro-lamports)"
                            );
                            return fee_u64;
                        }
                        debug!("Helius response missing fee data, using default");
                        self.default_fee
                    }
                    Err(e) => {
                        debug!(error = %e, "Failed to parse Helius response, using default");
                        self.default_fee
                    }
                }
            }
            Err(e) => {
                debug!(error = %e, "Helius API request failed, using default");
                self.default_fee
            }
        }
    }

    fn name(&self) -> &'static str {
        "Helius (getPriorityFeeEstimate)"
    }
}

// ============================================================================
// HELIUS DAS CLIENT
// ============================================================================

/// Helius Digital Asset Standard (DAS) client for compliance checks
///
/// Uses the `getAssetsByOwner` API to fetch all assets owned by a wallet
/// and checks them against a sanctioned collection list.
pub struct HeliusDasClient {
    rpc_url: String,
    http_client: reqwest::Client,
}

impl HeliusDasClient {
    pub fn new(rpc_url: &str) -> Self {
        info!("Helius DAS Check enabled");
        Self {
            rpc_url: rpc_url.to_string(),
            http_client: reqwest::Client::new(),
        }
    }

    /// Check if a wallet holds any assets from sanctioned collections
    ///
    /// # Arguments
    /// * `owner` - The wallet address (Base58) to check
    ///
    /// # Returns
    /// * `Ok(true)` - Wallet is compliant (no sanctioned assets)
    /// * `Ok(false)` - Wallet holds sanctioned assets
    /// * `Err(_)` - API error (caller should decide how to handle)
    pub async fn check_wallet_compliance(&self, owner: &str) -> Result<bool, AppError> {
        info!(wallet = %owner, "Helius DAS Check: Scanning wallet assets");

        let params = serde_json::json!({
            "ownerAddress": owner,
            "page": 1,
            "limit": 100,
            "displayOptions": {
                "showCollectionMetadata": true
            }
        });

        let request = JsonRpcRequest {
            jsonrpc: "2.0",
            id: "helius-das",
            method: "getAssetsByOwner".to_string(),
            params,
        };

        let response = self
            .http_client
            .post(&self.rpc_url)
            .json(&request)
            .send()
            .await
            .map_err(|e| {
                AppError::Blockchain(BlockchainError::HeliusApiError(format!(
                    "DAS API request failed: {}",
                    e
                )))
            })?;

        let rpc_response: JsonRpcResponse<DasAssetsResponse> =
            response.json().await.map_err(|e| {
                AppError::Blockchain(BlockchainError::HeliusApiError(format!(
                    "Failed to parse DAS response: {}",
                    e
                )))
            })?;

        if let Some(error) = rpc_response.error {
            return Err(AppError::Blockchain(BlockchainError::HeliusApiError(
                error.message,
            )));
        }

        let result = rpc_response.result.ok_or_else(|| {
            AppError::Blockchain(BlockchainError::HeliusApiError(
                "Empty DAS response".to_string(),
            ))
        })?;

        // Check each asset against sanctioned collections
        for asset in &result.items {
            if let Some(grouping) = &asset.grouping {
                for group in grouping {
                    if group.group_key == "collection" {
                        if let Some(group_value) = &group.group_value {
                            if SANCTIONED_COLLECTIONS.contains(&group_value.as_str()) {
                                warn!(
                                    wallet = %owner,
                                    sanctioned_collection = %group_value,
                                    asset_id = %asset.id,
                                    "DAS Check FAILED: Wallet holds sanctioned asset"
                                );
                                return Ok(false);
                            }
                        }
                    }
                }
            }
        }

        let asset_count = result.items.len();
        info!(
            wallet = %owner,
            assets_checked = asset_count,
            "DAS Check PASSED: No sanctioned assets found"
        );
        Ok(true)
    }
}

// ============================================================================
// DAS RESPONSE TYPES
// ============================================================================

#[derive(Debug, Deserialize)]
pub struct DasAssetsResponse {
    #[allow(dead_code)]
    pub total: Option<u64>,
    #[allow(dead_code)]
    pub limit: Option<u64>,
    #[allow(dead_code)]
    pub page: Option<u64>,
    pub items: Vec<DasAsset>,
}

#[derive(Debug, Deserialize)]
pub struct DasAsset {
    pub id: String,
    #[allow(dead_code)]
    pub interface: Option<String>,
    #[allow(dead_code)]
    pub content: Option<DasAssetContent>,
    pub grouping: Option<Vec<DasAssetGroup>>,
}

#[derive(Debug, Deserialize)]
pub struct DasAssetContent {
    #[allow(dead_code)]
    pub json_uri: Option<String>,
    #[allow(dead_code)]
    pub metadata: Option<DasAssetMetadata>,
}

#[derive(Debug, Deserialize)]
pub struct DasAssetMetadata {
    #[allow(dead_code)]
    pub name: Option<String>,
    #[allow(dead_code)]
    pub symbol: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct DasAssetGroup {
    pub group_key: String,
    pub group_value: Option<String>,
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sanctioned_collection_check() {
        assert!(SANCTIONED_COLLECTIONS.contains(&"SANCTIONED111111111111111111111111111111111"));
        assert!(!SANCTIONED_COLLECTIONS.contains(&"SAFE11111111111111111111111111111111111111"));
    }

    #[tokio::test]
    async fn test_helius_fee_strategy_name() {
        // We can't test the actual API call without mocking, but we can test the name
        let strategy = HeliusFeeStrategy {
            rpc_url: "https://test.helius-rpc.com".to_string(),
            http_client: reqwest::Client::new(),
            default_fee: 100,
        };
        assert_eq!(strategy.name(), "Helius (getPriorityFeeEstimate)");
    }

    #[test]
    fn test_das_client_creation() {
        // Just verify the client can be created
        let _client = HeliusDasClient::new("https://test.helius-rpc.com");
    }
}

===== ./infra/blockchain/mod.rs =====
//! Blockchain client implementations.
//!
//! This module provides blockchain interaction abstractions with provider-specific
//! strategy implementations for Helius, QuickNode, and standard Solana RPC.

pub mod helius;
pub mod quicknode;
pub mod solana;
pub mod strategies;

// Re-export main types
pub use solana::{RpcBlockchainClient, RpcClientConfig, signing_key_from_base58};

// Re-export strategy types
pub use strategies::{FeeStrategy, RpcProviderType, SubmissionStrategy};

// Re-export Helius-specific types
pub use helius::{HeliusDasClient, HeliusFeeStrategy, SANCTIONED_COLLECTIONS};

// Re-export QuickNode-specific types
pub use quicknode::{
    QuickNodePrivateSubmissionStrategy, QuickNodeSubmissionConfig, QuickNodeTokenApiClient,
    StandardSubmissionStrategy, TokenActivityInfo,
};

===== ./infra/blockchain/quicknode.rs =====
//! QuickNode RPC provider integration.
//!
//! Implements QuickNode-specific features:
//! - Private Transaction Submission via Jito Bundles (Ghost Mode)
//! - Token API for anonymity set analysis
//! - Priority Fee Estimation (moved from strategies.rs)
//!
//! # Ghost Mode
//! Transactions are submitted directly to Jito block builders, bypassing
//! the public mempool for enhanced privacy (MEV protection).
//!
//! # Usage
//! QuickNode features are auto-activated when the RPC URL contains `quiknode.pro`
//! or `quicknode.com`.

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use tracing::{debug, info, warn};

use crate::domain::{AppError, BlockchainError};

use super::strategies::SubmissionStrategy;

// ============================================================================
// QUICKNODE SUBMISSION CONFIG
// ============================================================================

/// Configuration for QuickNode private submission
#[derive(Debug, Clone)]
pub struct QuickNodeSubmissionConfig {
    /// QuickNode RPC URL
    pub rpc_url: String,
    /// Enable Jito bundle submission for private transactions
    pub enable_jito_bundles: bool,
    /// Tip amount for Jito block builders (in lamports)
    pub tip_lamports: u64,
    /// Maximum retries for bundle submission
    pub max_bundle_retries: u32,
}

impl Default for QuickNodeSubmissionConfig {
    fn default() -> Self {
        Self {
            rpc_url: String::new(),
            enable_jito_bundles: true,
            tip_lamports: 1_000, // 0.000001 SOL
            max_bundle_retries: 2,
        }
    }
}

// ============================================================================
// JITO BUNDLE TYPES
// ============================================================================

/// Jito bundle submission request
#[derive(Debug, Serialize)]
struct JitoBundleRequest {
    jsonrpc: &'static str,
    id: u64,
    method: String,
    params: Vec<Vec<String>>,
}

/// Jito bundle submission response
#[derive(Debug, Deserialize)]
struct JitoBundleResponse {
    result: Option<String>,
    error: Option<JitoError>,
}

#[derive(Debug, Deserialize)]
struct JitoError {
    code: i64,
    message: String,
}

/// Standard sendTransaction request
#[derive(Debug, Serialize)]
struct SendTransactionRequest {
    jsonrpc: &'static str,
    id: u64,
    method: String,
    params: Vec<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
struct SendTransactionResponse {
    result: Option<String>,
    error: Option<RpcError>,
}

#[derive(Debug, Deserialize)]
struct RpcError {
    code: i64,
    message: String,
}

// ============================================================================
// QUICKNODE PRIVATE SUBMISSION STRATEGY
// ============================================================================

/// QuickNode Private Submission Strategy using Jito Bundles
///
/// Submits transactions directly to Jito block builders, bypassing the
/// public mempool for enhanced privacy (Ghost Mode).
///
/// # Graceful Degradation
/// If Jito submission fails, automatically falls back to standard
/// `sendTransaction` to ensure high availability.
pub struct QuickNodePrivateSubmissionStrategy {
    config: QuickNodeSubmissionConfig,
    http_client: reqwest::Client,
}

impl QuickNodePrivateSubmissionStrategy {
    /// Create a new private submission strategy
    pub fn new(config: QuickNodeSubmissionConfig) -> Self {
        info!(
            rpc_url = %config.rpc_url,
            jito_enabled = config.enable_jito_bundles,
            tip_lamports = config.tip_lamports,
            "🔒 QuickNode Private Submission Strategy (Ghost Mode) initialized"
        );
        Self {
            config,
            http_client: reqwest::Client::new(),
        }
    }

    /// Submit transaction as a Jito bundle for private submission
    async fn submit_jito_bundle(&self, serialized_tx: &str) -> Result<String, AppError> {
        debug!(
            tx_len = serialized_tx.len(),
            "Attempting Jito bundle submission"
        );

        // QuickNode's Jito integration uses qn_broadcastBundle
        let request = JitoBundleRequest {
            jsonrpc: "2.0",
            id: 1,
            method: "qn_broadcastBundle".to_string(),
            params: vec![vec![serialized_tx.to_string()]],
        };

        let response = self
            .http_client
            .post(&self.config.rpc_url)
            .json(&request)
            .send()
            .await
            .map_err(|e| {
                AppError::Blockchain(BlockchainError::JitoBundleFailed(format!(
                    "HTTP request failed: {}",
                    e
                )))
            })?;

        let bundle_response: JitoBundleResponse = response.json().await.map_err(|e| {
            AppError::Blockchain(BlockchainError::JitoBundleFailed(format!(
                "Failed to parse response: {}",
                e
            )))
        })?;

        if let Some(error) = bundle_response.error {
            // Check for "method not found" which means Jito isn't available
            if error.code == -32601 {
                return Err(AppError::Blockchain(
                    BlockchainError::PrivateSubmissionFallback(
                        "qn_broadcastBundle not available on this endpoint".to_string(),
                    ),
                ));
            }
            return Err(AppError::Blockchain(BlockchainError::JitoBundleFailed(
                error.message,
            )));
        }

        bundle_response.result.ok_or_else(|| {
            AppError::Blockchain(BlockchainError::JitoBundleFailed(
                "Empty response from Jito".to_string(),
            ))
        })
    }

    /// Submit transaction via standard sendTransaction RPC
    async fn submit_standard(
        &self,
        serialized_tx: &str,
        skip_preflight: bool,
    ) -> Result<String, AppError> {
        debug!(
            skip_preflight = skip_preflight,
            "Using standard sendTransaction"
        );

        let params = vec![
            serde_json::Value::String(serialized_tx.to_string()),
            serde_json::json!({
                "skipPreflight": skip_preflight,
                "preflightCommitment": "confirmed",
                "encoding": "base58"
            }),
        ];

        let request = SendTransactionRequest {
            jsonrpc: "2.0",
            id: 1,
            method: "sendTransaction".to_string(),
            params,
        };

        let response = self
            .http_client
            .post(&self.config.rpc_url)
            .json(&request)
            .send()
            .await
            .map_err(|e| {
                AppError::Blockchain(BlockchainError::RpcError(format!(
                    "sendTransaction HTTP failed: {}",
                    e
                )))
            })?;

        let tx_response: SendTransactionResponse = response.json().await.map_err(|e| {
            AppError::Blockchain(BlockchainError::RpcError(format!(
                "Failed to parse sendTransaction response: {}",
                e
            )))
        })?;

        if let Some(error) = tx_response.error {
            return Err(AppError::Blockchain(BlockchainError::TransactionFailed(
                format!("{}: {}", error.code, error.message),
            )));
        }

        tx_response.result.ok_or_else(|| {
            AppError::Blockchain(BlockchainError::RpcError(
                "Empty sendTransaction response".to_string(),
            ))
        })
    }
}

#[async_trait]
impl SubmissionStrategy for QuickNodePrivateSubmissionStrategy {
    async fn submit_transaction(
        &self,
        serialized_tx: &str,
        skip_preflight: bool,
    ) -> Result<String, AppError> {
        // Attempt Jito bundle submission first if enabled
        if self.config.enable_jito_bundles {
            match self.submit_jito_bundle(serialized_tx).await {
                Ok(signature) => {
                    info!(
                        signature = %signature,
                        "🔒 Ghost Mode: Transaction submitted privately via Jito bundle"
                    );
                    return Ok(signature);
                }
                Err(e) => {
                    // Check if it's a fallback-worthy error
                    let should_fallback = matches!(
                        &e,
                        AppError::Blockchain(BlockchainError::PrivateSubmissionFallback(_))
                            | AppError::Blockchain(BlockchainError::JitoBundleFailed(_))
                    );

                    if should_fallback {
                        warn!(
                            error = %e,
                            "Ghost Mode unavailable, falling back to standard submission"
                        );
                    } else {
                        // For other errors, don't fallback (e.g., network errors)
                        return Err(e);
                    }
                }
            }
        }

        // Fallback to standard sendTransaction
        let signature = self.submit_standard(serialized_tx, skip_preflight).await?;
        info!(
            signature = %signature,
            "Transaction submitted via standard sendTransaction (fallback)"
        );
        Ok(signature)
    }

    fn name(&self) -> &'static str {
        "QuickNode (Ghost Mode / Jito)"
    }

    fn supports_private_submission(&self) -> bool {
        self.config.enable_jito_bundles
    }
}

// ============================================================================
// STANDARD SUBMISSION STRATEGY
// ============================================================================

/// Standard submission strategy using sendTransaction RPC
///
/// Used as the default for non-QuickNode providers and as a fallback
/// when private submission is unavailable.
pub struct StandardSubmissionStrategy {
    rpc_url: String,
    http_client: reqwest::Client,
}

impl StandardSubmissionStrategy {
    /// Create a new standard submission strategy
    pub fn new(rpc_url: &str) -> Self {
        debug!(rpc_url = %rpc_url, "Standard submission strategy initialized");
        Self {
            rpc_url: rpc_url.to_string(),
            http_client: reqwest::Client::new(),
        }
    }
}

#[async_trait]
impl SubmissionStrategy for StandardSubmissionStrategy {
    async fn submit_transaction(
        &self,
        serialized_tx: &str,
        skip_preflight: bool,
    ) -> Result<String, AppError> {
        let params = vec![
            serde_json::Value::String(serialized_tx.to_string()),
            serde_json::json!({
                "skipPreflight": skip_preflight,
                "preflightCommitment": "confirmed",
                "encoding": "base58"
            }),
        ];

        let request = SendTransactionRequest {
            jsonrpc: "2.0",
            id: 1,
            method: "sendTransaction".to_string(),
            params,
        };

        let response = self
            .http_client
            .post(&self.rpc_url)
            .json(&request)
            .send()
            .await
            .map_err(|e| {
                AppError::Blockchain(BlockchainError::RpcError(format!(
                    "sendTransaction failed: {}",
                    e
                )))
            })?;

        let tx_response: SendTransactionResponse = response.json().await.map_err(|e| {
            AppError::Blockchain(BlockchainError::RpcError(format!(
                "Failed to parse response: {}",
                e
            )))
        })?;

        if let Some(error) = tx_response.error {
            return Err(AppError::Blockchain(BlockchainError::TransactionFailed(
                format!("{}: {}", error.code, error.message),
            )));
        }

        let signature = tx_response.result.ok_or_else(|| {
            AppError::Blockchain(BlockchainError::RpcError("Empty response".to_string()))
        })?;

        debug!(signature = %signature, "Transaction submitted via sendTransaction");
        Ok(signature)
    }

    fn name(&self) -> &'static str {
        "Standard (sendTransaction)"
    }

    fn supports_private_submission(&self) -> bool {
        false
    }
}

// ============================================================================
// QUICKNODE TOKEN API CLIENT
// ============================================================================

/// Token activity information for anonymity set analysis
#[derive(Debug, Clone)]
pub struct TokenActivityInfo {
    /// Token mint address
    pub token_mint: String,
    /// Number of recent transactions
    pub recent_tx_count: u64,
    /// Timestamp of last activity (if available)
    pub last_activity_timestamp: Option<DateTime<Utc>>,
    /// Whether this is an estimate (cached/approximated)
    pub is_estimate: bool,
}

/// QuickNode Token API client for privacy health checks
///
/// Fetches token metadata and recent transaction history to assess
/// the anonymity set health before confidential transfers.
pub struct QuickNodeTokenApiClient {
    rpc_url: String,
    http_client: reqwest::Client,
}

impl QuickNodeTokenApiClient {
    /// Create a new Token API client
    pub fn new(rpc_url: &str) -> Self {
        info!(rpc_url = %rpc_url, "QuickNode Token API client initialized");
        Self {
            rpc_url: rpc_url.to_string(),
            http_client: reqwest::Client::new(),
        }
    }

    /// Get recent transaction activity for a token mint
    ///
    /// Uses QuickNode's enhanced RPC methods to fetch token activity.
    /// Falls back to signature counting if advanced APIs aren't available.
    pub async fn get_recent_activity(
        &self,
        token_mint: &str,
        lookback_minutes: u64,
    ) -> Result<TokenActivityInfo, AppError> {
        debug!(
            token_mint = %token_mint,
            lookback_minutes = lookback_minutes,
            "Fetching token activity for privacy health check"
        );

        // Try QuickNode's qn_getTokenMetadata first
        match self.get_token_metadata(token_mint).await {
            Ok(info) => {
                debug!(
                    token_mint = %token_mint,
                    recent_tx_count = info.recent_tx_count,
                    "Token metadata fetched successfully"
                );
                Ok(info)
            }
            Err(e) => {
                // Fallback: Use getSignaturesForAddress to count recent transactions
                debug!(
                    error = %e,
                    "qn_getTokenMetadata failed, falling back to signature counting"
                );
                self.count_recent_signatures(token_mint, lookback_minutes)
                    .await
            }
        }
    }

    /// Fetch token metadata using QuickNode's enhanced API
    async fn get_token_metadata(&self, token_mint: &str) -> Result<TokenActivityInfo, AppError> {
        #[derive(Debug, Serialize)]
        struct TokenMetadataRequest {
            jsonrpc: &'static str,
            id: u64,
            method: String,
            params: serde_json::Value,
        }

        #[derive(Debug, Deserialize)]
        struct TokenMetadataResponse {
            result: Option<TokenMetadata>,
            error: Option<RpcError>,
        }

        #[derive(Debug, Deserialize)]
        #[serde(rename_all = "camelCase")]
        struct TokenMetadata {
            #[allow(dead_code)]
            #[serde(default)]
            holder_count: Option<u64>,
            #[serde(default)]
            transfer_count_24h: Option<u64>,
        }

        let request = TokenMetadataRequest {
            jsonrpc: "2.0",
            id: 1,
            method: "qn_getTokenMetadata".to_string(),
            params: serde_json::json!({ "mint": token_mint }),
        };

        let response = self
            .http_client
            .post(&self.rpc_url)
            .json(&request)
            .send()
            .await
            .map_err(|e| {
                AppError::Blockchain(BlockchainError::QuickNodeApiError(format!(
                    "Token API request failed: {}",
                    e
                )))
            })?;

        let metadata_response: TokenMetadataResponse = response.json().await.map_err(|e| {
            AppError::Blockchain(BlockchainError::QuickNodeApiError(format!(
                "Failed to parse token metadata: {}",
                e
            )))
        })?;

        if let Some(error) = metadata_response.error {
            return Err(AppError::Blockchain(BlockchainError::QuickNodeApiError(
                error.message,
            )));
        }

        let metadata = metadata_response.result.ok_or_else(|| {
            AppError::Blockchain(BlockchainError::QuickNodeApiError(
                "Empty token metadata response".to_string(),
            ))
        })?;

        // Use transfer_count_24h as a proxy for recent activity
        // Scale it down for our lookback window (e.g., 10 minutes = 10/1440 of 24h)
        let daily_transfers = metadata.transfer_count_24h.unwrap_or(0);
        let lookback_fraction = 10.0 / 1440.0; // 10 minutes / 24 hours
        let estimated_recent = (daily_transfers as f64 * lookback_fraction).round() as u64;

        Ok(TokenActivityInfo {
            token_mint: token_mint.to_string(),
            recent_tx_count: estimated_recent.max(1), // At least 1 if token exists
            last_activity_timestamp: None,
            is_estimate: true,
        })
    }

    /// Fallback: Count recent signatures for the token mint address
    async fn count_recent_signatures(
        &self,
        token_mint: &str,
        _lookback_minutes: u64,
    ) -> Result<TokenActivityInfo, AppError> {
        #[derive(Debug, Serialize)]
        struct SignaturesRequest {
            jsonrpc: &'static str,
            id: u64,
            method: String,
            params: Vec<serde_json::Value>,
        }

        #[derive(Debug, Deserialize)]
        struct SignaturesResponse {
            result: Option<Vec<SignatureInfo>>,
            error: Option<RpcError>,
        }

        #[derive(Debug, Deserialize)]
        struct SignatureInfo {
            #[allow(dead_code)]
            signature: String,
        }

        let request = SignaturesRequest {
            jsonrpc: "2.0",
            id: 1,
            method: "getSignaturesForAddress".to_string(),
            params: vec![
                serde_json::Value::String(token_mint.to_string()),
                serde_json::json!({ "limit": 100 }),
            ],
        };

        let response = self
            .http_client
            .post(&self.rpc_url)
            .json(&request)
            .send()
            .await
            .map_err(|e| {
                AppError::Blockchain(BlockchainError::QuickNodeApiError(format!(
                    "Signature fetch failed: {}",
                    e
                )))
            })?;

        let sig_response: SignaturesResponse = response.json().await.map_err(|e| {
            AppError::Blockchain(BlockchainError::QuickNodeApiError(format!(
                "Failed to parse signatures: {}",
                e
            )))
        })?;

        if let Some(error) = sig_response.error {
            return Err(AppError::Blockchain(BlockchainError::QuickNodeApiError(
                error.message,
            )));
        }

        let signatures = sig_response.result.unwrap_or_default();

        Ok(TokenActivityInfo {
            token_mint: token_mint.to_string(),
            recent_tx_count: signatures.len() as u64,
            last_activity_timestamp: None,
            is_estimate: false,
        })
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_quicknode_submission_config_default() {
        let config = QuickNodeSubmissionConfig::default();
        assert!(config.enable_jito_bundles);
        assert_eq!(config.tip_lamports, 1_000);
        assert_eq!(config.max_bundle_retries, 2);
    }

    #[test]
    fn test_standard_submission_strategy_name() {
        let strategy = StandardSubmissionStrategy::new("https://api.devnet.solana.com");
        assert_eq!(strategy.name(), "Standard (sendTransaction)");
        assert!(!strategy.supports_private_submission());
    }

    #[test]
    fn test_quicknode_private_submission_strategy_name() {
        let config = QuickNodeSubmissionConfig {
            rpc_url: "https://test.quiknode.pro/xxx".to_string(),
            enable_jito_bundles: true,
            tip_lamports: 1_000,
            max_bundle_retries: 2,
        };
        let strategy = QuickNodePrivateSubmissionStrategy::new(config);
        assert_eq!(strategy.name(), "QuickNode (Ghost Mode / Jito)");
        assert!(strategy.supports_private_submission());
    }

    #[test]
    fn test_token_activity_info() {
        let info = TokenActivityInfo {
            token_mint: "test_mint".to_string(),
            recent_tx_count: 10,
            last_activity_timestamp: Some(Utc::now()),
            is_estimate: false,
        };
        assert_eq!(info.token_mint, "test_mint");
        assert_eq!(info.recent_tx_count, 10);
        assert!(!info.is_estimate);
    }

    #[test]
    fn test_quicknode_token_api_client_creation() {
        let client = QuickNodeTokenApiClient::new("https://test.quiknode.pro/xxx");
        assert_eq!(client.rpc_url, "https://test.quiknode.pro/xxx");
    }
}

===== ./infra/blockchain/solana.rs =====
//! Blockchain RPC client implementation for Solana.
//!
//! This module provides both mock and real blockchain interactions.
//! Real blockchain functionality is enabled with the `real-blockchain` feature.

use async_trait::async_trait;
use ed25519_dalek::{Signer, SigningKey};
use reqwest::Client;
use secrecy::{ExposeSecret, SecretString};
use serde::{Deserialize, Serialize, de::DeserializeOwned};
use std::time::Duration;
use tracing::{debug, info, instrument, warn};

// Solana SDK imports (v3.0)
use base64::{Engine as _, prelude::BASE64_STANDARD};
use solana_client::nonblocking::rpc_client::RpcClient as SolanaRpcClient;
use solana_commitment_config::CommitmentConfig;
use solana_compute_budget_interface::ComputeBudgetInstruction;
use solana_sdk::{
    instruction::Instruction,
    pubkey::Pubkey,
    signer::{Signer as SolanaSigner, keypair::Keypair},
    transaction::Transaction,
};
use solana_system_interface::instruction as system_instruction;
use solana_zk_sdk::zk_elgamal_proof_program::instruction::ProofInstruction;
use spl_associated_token_account::{
    get_associated_token_address_with_program_id,
    instruction::create_associated_token_account_idempotent,
};

use spl_token_interface::instruction as token_instruction;

use crate::domain::types::TransferType;
use crate::domain::{AppError, BlockchainClient, BlockchainError, TransferRequest};

/// Configuration for the RPC client
#[derive(Debug, Clone)]
pub struct RpcClientConfig {
    pub timeout: Duration,
    pub max_retries: u32,
    pub retry_delay: Duration,
    pub confirmation_timeout: Duration,
}

impl Default for RpcClientConfig {
    fn default() -> Self {
        Self {
            timeout: Duration::from_secs(30),
            max_retries: 3,
            retry_delay: Duration::from_millis(500),
            confirmation_timeout: Duration::from_secs(60),
        }
    }
}

/// Abstract provider for Solana RPC interactions to enable testing
#[async_trait]
pub trait SolanaRpcProvider: Send + Sync {
    /// Send a JSON-RPC request
    async fn send_request(
        &self,
        method: &str,
        params: serde_json::Value,
    ) -> Result<serde_json::Value, AppError>;

    /// Get the provider's public key
    fn public_key(&self) -> String;

    /// Sign a message
    fn sign(&self, message: &[u8]) -> String;
}

/// HTTP-based Solana RPC provider
pub struct HttpSolanaRpcProvider {
    http_client: Client,
    rpc_url: String,
    signing_key: SigningKey,
}

impl HttpSolanaRpcProvider {
    pub fn new(
        rpc_url: &str,
        signing_key: SigningKey,
        timeout: Duration,
    ) -> Result<Self, AppError> {
        let http_client = Client::builder()
            .timeout(timeout)
            .build()
            .map_err(|e| AppError::Blockchain(BlockchainError::Connection(e.to_string())))?;

        Ok(Self {
            http_client,
            rpc_url: rpc_url.to_string(),
            signing_key,
        })
    }
}

#[async_trait]
impl SolanaRpcProvider for HttpSolanaRpcProvider {
    async fn send_request(
        &self,
        method: &str,
        params: serde_json::Value,
    ) -> Result<serde_json::Value, AppError> {
        let request = JsonRpcRequest {
            jsonrpc: "2.0",
            id: 1,
            method: method.to_string(),
            params,
        };

        let response = self
            .http_client
            .post(&self.rpc_url)
            .json(&request)
            .send()
            .await
            .map_err(|e| {
                if e.is_timeout() {
                    AppError::Blockchain(BlockchainError::Timeout(e.to_string()))
                } else {
                    AppError::Blockchain(BlockchainError::RpcError(e.to_string()))
                }
            })?;

        let rpc_response: JsonRpcResponse<serde_json::Value> = response
            .json()
            .await
            .map_err(|e| AppError::Blockchain(BlockchainError::RpcError(e.to_string())))?;

        if let Some(error) = rpc_response.error {
            // Check for insufficient funds error
            if error.message.contains("insufficient") || error.code == -32002 {
                return Err(AppError::Blockchain(BlockchainError::InsufficientFunds));
            }
            return Err(AppError::Blockchain(BlockchainError::RpcError(format!(
                "{}: {}",
                error.code, error.message
            ))));
        }

        rpc_response.result.ok_or_else(|| {
            AppError::Blockchain(BlockchainError::RpcError("Empty response".to_string()))
        })
    }

    fn public_key(&self) -> String {
        bs58::encode(self.signing_key.verifying_key().as_bytes()).into_string()
    }

    fn sign(&self, message: &[u8]) -> String {
        let signature = self.signing_key.sign(message);
        bs58::encode(signature.to_bytes()).into_string()
    }
}

/// Solana RPC blockchain client with provider strategy pattern
///
/// Auto-detects the RPC provider (Helius, QuickNode, Standard) and activates
/// premium features accordingly:
/// - Helius: Priority fee estimation, DAS compliance checks
/// - QuickNode: Priority fee estimation
/// - Standard: Fallback fee strategy
pub struct RpcBlockchainClient {
    provider: Box<dyn SolanaRpcProvider>,
    config: RpcClientConfig,
    /// Solana SDK RPC client for SDK-based operations
    sdk_client: Option<SolanaRpcClient>,
    /// Solana keypair for signing transactions
    keypair: Option<Keypair>,
    /// Auto-detected provider type
    provider_type: super::strategies::RpcProviderType,
    /// Priority fee estimation strategy
    fee_strategy: Box<dyn super::strategies::FeeStrategy>,
    /// Helius DAS client for compliance checks (only for Helius provider)
    das_client: Option<super::helius::HeliusDasClient>,
    /// RPC URL (stored for strategy use and future integration)
    #[allow(dead_code)]
    rpc_url: String,
}

#[derive(Debug, Serialize)]
struct JsonRpcRequest<T: Serialize> {
    jsonrpc: &'static str,
    id: u64,
    method: String,
    params: T,
}

#[derive(Debug, Deserialize)]
struct JsonRpcResponse<T> {
    result: Option<T>,
    error: Option<JsonRpcError>,
}

#[derive(Debug, Deserialize)]
struct JsonRpcError {
    code: i64,
    message: String,
}

#[derive(Debug, Deserialize)]
struct BlockhashResponse {
    blockhash: String,
}

#[derive(Debug, Deserialize)]
struct BlockhashResult {
    value: BlockhashResponse,
}

#[derive(Debug, Deserialize)]
struct SignatureStatus {
    err: Option<serde_json::Value>,
    #[serde(rename = "confirmationStatus")]
    confirmation_status: Option<String>,
}

#[derive(Debug, Deserialize)]
struct SignatureStatusResult {
    value: Vec<Option<SignatureStatus>>,
}

/// Response structure for QuickNode's qn_estimatePriorityFees API
#[allow(dead_code)] // Scaffolded for QuickNode fee strategy
#[derive(Debug, Deserialize)]
struct QuickNodePriorityFeeResponse {
    per_compute_unit: Option<QuickNodePriorityFeeLevel>,
}

/// Priority fee levels from QuickNode API (values in micro-lamports)
#[allow(dead_code)] // Scaffolded for QuickNode fee strategy
#[derive(Debug, Deserialize)]
struct QuickNodePriorityFeeLevel {
    high: Option<f64>,
    #[allow(dead_code)]
    medium: Option<f64>,
    #[allow(dead_code)]
    low: Option<f64>,
}

impl RpcBlockchainClient {
    /// Create a new RPC blockchain client with custom configuration
    ///
    /// Automatically detects the RPC provider type and activates premium features:
    /// - **Helius**: Priority fee estimation via `getPriorityFeeEstimate`, DAS compliance checks
    /// - **QuickNode**: Priority fee estimation via `qn_estimatePriorityFees`
    /// - **Standard**: Fallback to static priority fee
    pub fn new(
        rpc_url: &str,
        signing_key: SigningKey,
        config: RpcClientConfig,
    ) -> Result<Self, AppError> {
        use super::helius::{HeliusDasClient, HeliusFeeStrategy};
        use super::strategies::{FallbackFeeStrategy, QuickNodeFeeStrategy, RpcProviderType};

        let provider = HttpSolanaRpcProvider::new(rpc_url, signing_key.clone(), config.timeout)?;

        // Auto-detect provider type from URL
        let provider_type = RpcProviderType::detect(rpc_url);
        info!(
            provider = %provider_type.name(),
            rpc_url = %rpc_url,
            "Detected RPC provider type"
        );

        // Select fee strategy and DAS client based on provider type
        let (fee_strategy, das_client): (
            Box<dyn super::strategies::FeeStrategy>,
            Option<HeliusDasClient>,
        ) = match &provider_type {
            RpcProviderType::Helius => {
                info!("Helius Priority Fee Strategy activated!");
                info!("Helius DAS Check enabled");
                (
                    Box::new(HeliusFeeStrategy::new(rpc_url)),
                    Some(HeliusDasClient::new(rpc_url)),
                )
            }
            RpcProviderType::QuickNode => {
                info!("QuickNode Priority Fee Strategy activated");
                (Box::new(QuickNodeFeeStrategy::new(rpc_url)), None)
            }
            RpcProviderType::Standard => {
                info!("Standard RPC (fallback fee strategy)");
                (Box::new(FallbackFeeStrategy::new()), None)
            }
        };

        // Create Solana SDK keypair from ed25519-dalek signing key
        let keypair_bytes = signing_key.to_keypair_bytes();
        let keypair = Keypair::try_from(keypair_bytes.as_slice()).map_err(|e| {
            AppError::Blockchain(BlockchainError::InvalidSignature(format!(
                "Failed to create keypair: {}",
                e
            )))
        })?;

        // Create Solana SDK RPC client
        let sdk_client = SolanaRpcClient::new_with_timeout_and_commitment(
            rpc_url.to_string(),
            config.timeout,
            CommitmentConfig::confirmed(),
        );

        info!(
            rpc_url = %rpc_url,
            provider = %provider_type.name(),
            fee_strategy = %fee_strategy.name(),
            das_enabled = das_client.is_some(),
            "Created blockchain client with SDK support"
        );

        Ok(Self {
            provider: Box::new(provider),
            config,
            sdk_client: Some(sdk_client),
            keypair: Some(keypair),
            provider_type,
            fee_strategy,
            das_client,
            rpc_url: rpc_url.to_string(),
        })
    }

    /// Create a new RPC blockchain client with default configuration
    pub fn with_defaults(rpc_url: &str, signing_key: SigningKey) -> Result<Self, AppError> {
        Self::new(rpc_url, signing_key, RpcClientConfig::default())
    }

    /// Create a new client with a specific provider (useful for testing)
    pub fn with_provider(provider: Box<dyn SolanaRpcProvider>, config: RpcClientConfig) -> Self {
        use super::strategies::{FallbackFeeStrategy, RpcProviderType};

        Self {
            provider,
            config,
            sdk_client: None,
            keypair: None,
            provider_type: RpcProviderType::Standard,
            fee_strategy: Box::new(FallbackFeeStrategy::new()),
            das_client: None,
            rpc_url: String::new(),
        }
    }

    /// Get the detected provider type
    pub fn provider_type(&self) -> &super::strategies::RpcProviderType {
        &self.provider_type
    }

    /// Check if Helius DAS is available
    pub fn has_das_support(&self) -> bool {
        self.das_client.is_some()
    }

    /// Get the public key as base58 string
    #[must_use]
    pub fn public_key(&self) -> String {
        self.provider.public_key()
    }

    /// Sign a message and return the signature as base58
    #[must_use]
    pub fn sign(&self, message: &[u8]) -> String {
        self.provider.sign(message)
    }

    /// Make an RPC call with retries
    #[instrument(skip(self, params))]
    async fn rpc_call<P: Serialize + Send + Sync, R: DeserializeOwned + Send>(
        &self,
        method: &str,
        params: P,
    ) -> Result<R, AppError> {
        // Serialize parameters to JSON Value
        let params_value = serde_json::to_value(params).map_err(|e| {
            AppError::Blockchain(BlockchainError::RpcError(format!(
                "Serialization error: {}",
                e
            )))
        })?;

        let mut last_error = None;
        for attempt in 0..=self.config.max_retries {
            if attempt > 0 {
                tokio::time::sleep(self.config.retry_delay).await;
            }
            match self
                .provider
                .send_request(method, params_value.clone())
                .await
            {
                Ok(result_value) => {
                    // Deserialize result from JSON Value
                    return serde_json::from_value(result_value).map_err(|e| {
                        AppError::Blockchain(BlockchainError::RpcError(format!(
                            "Deserialization error: {}",
                            e
                        )))
                    });
                }
                Err(e) => {
                    warn!(attempt = attempt, error = ?e, method = %method, "RPC call failed");
                    last_error = Some(e);
                }
            }
        }
        Err(last_error.unwrap_or_else(|| {
            AppError::Blockchain(BlockchainError::RpcError("Unknown error".to_string()))
        }))
    }

    /// Get priority fee using the appropriate strategy for the detected provider.
    ///
    /// This method delegates to the configured fee strategy:
    /// - Helius: Uses `getPriorityFeeEstimate` for transaction-aware estimation
    /// - QuickNode: Uses `qn_estimatePriorityFees` for global estimation
    /// - Standard: Returns a static fallback value
    ///
    /// # Arguments
    /// * `serialized_tx` - Optional Base58-encoded serialized transaction
    ///   (used by Helius for per-account fee estimation)
    async fn get_priority_fee(&self, serialized_tx: Option<&str>) -> u64 {
        self.fee_strategy.get_priority_fee(serialized_tx).await
    }

    /// Legacy method for backward compatibility - calls the new strategy-based method
    #[allow(dead_code)]
    async fn get_quicknode_priority_fee(&self) -> u64 {
        self.get_priority_fee(None).await
    }
}

#[async_trait]
impl BlockchainClient for RpcBlockchainClient {
    #[instrument(skip(self))]
    async fn health_check(&self) -> Result<(), AppError> {
        let _: u64 = self.rpc_call("getSlot", Vec::<()>::new()).await?;
        Ok(())
    }

    #[instrument(skip(self))]
    async fn submit_transaction(&self, request: &TransferRequest) -> Result<String, AppError> {
        info!(id = %request.id, "Submitting transaction for request");

        // Check if we have SDK client (for real transactions)
        if self.sdk_client.is_none() || self.keypair.is_none() {
            // Mock implementation for testing (when SDK client not available)
            debug!("Using mock implementation for submit_transaction");
            let signature = self.sign(request.id.as_bytes());
            return Ok(format!("tx_{}", &signature[..16]));
        }

        // Dispatch based on TransferType
        match &request.transfer_details {
            TransferType::Public { amount } => match &request.token_mint {
                Some(mint) => {
                    self.transfer_token(&request.to_address, mint, *amount)
                        .await
                }
                None => self.transfer_sol(&request.to_address, *amount).await,
            },
            TransferType::Confidential {
                new_decryptable_available_balance,
                equality_proof,
                ciphertext_validity_proof,
                range_proof,
            } => {
                let mint = request.token_mint.as_ref().ok_or_else(|| {
                    AppError::Validation(crate::domain::ValidationError::InvalidField {
                        field: "token_mint".to_string(),
                        message: "Token mint is required for confidential transfers".to_string(),
                    })
                })?;

                self.transfer_confidential(
                    &request.to_address,
                    mint,
                    new_decryptable_available_balance,
                    equality_proof,
                    ciphertext_validity_proof,
                    range_proof,
                )
                .await
            }
        }
    }

    /// Transfer Token-2022 Confidential funds using Split Proof Verification
    ///
    /// This implementation uses the ZK ElGamal Proof Program to verify proofs
    /// in separate transactions before executing the transfer. This avoids
    /// the Solana transaction size limit (1232 bytes).
    ///
    /// # Architecture
    /// 1. Transaction 1: Verify all ZK proofs via separate verification instructions
    /// 2. Transaction 2: Execute ConfidentialTransfer::TransferWithSplitProofs
    ///
    /// # Arguments
    /// * `to_address` - Destination wallet (Base58)
    /// * `token_mint` - Token-2022 mint with confidential extensions (Base58)
    /// * `new_decryptable_available_balance_base64` - AES-encrypted balance (Base64)
    /// * `equality_proof_base64` - CiphertextCommitmentEqualityProofData (Base64)
    /// * `ciphertext_validity_proof_base64` - BatchedGroupedCiphertext3HandlesValidityProofData (Base64)
    /// * `range_proof_base64` - BatchedRangeProofU128Data (Base64)
    #[instrument(skip(self))]
    async fn transfer_confidential(
        &self,
        to_address: &str,
        token_mint: &str,
        new_decryptable_available_balance_base64: &str,
        equality_proof_base64: &str,
        ciphertext_validity_proof_base64: &str,
        range_proof_base64: &str,
    ) -> Result<String, AppError> {
        info!(
            to = %to_address,
            token_mint = %token_mint,
            "Processing confidential transfer with split proof verification"
        );

        let keypair = self.keypair.as_ref().ok_or_else(|| {
            AppError::Blockchain(BlockchainError::WalletError(
                "No keypair available for signing".to_string(),
            ))
        })?;
        let sdk_client = self.sdk_client.as_ref().ok_or_else(|| {
            AppError::Blockchain(BlockchainError::Connection(
                "No SDK client available".to_string(),
            ))
        })?;

        // Parse addresses
        let mint_pubkey: Pubkey = token_mint.parse().map_err(|_| {
            AppError::Validation(crate::domain::ValidationError::InvalidAddress(
                token_mint.to_string(),
            ))
        })?;
        let to_pubkey: Pubkey = to_address.parse().map_err(|_| {
            AppError::Validation(crate::domain::ValidationError::InvalidAddress(
                to_address.to_string(),
            ))
        })?;

        // Decode each proof component from Base64
        let new_decryptable_balance = BASE64_STANDARD
            .decode(new_decryptable_available_balance_base64)
            .map_err(|e| {
                AppError::Validation(crate::domain::ValidationError::InvalidField {
                    field: "new_decryptable_available_balance".to_string(),
                    message: format!("Invalid base64 encoding: {}", e),
                })
            })?;

        let equality_proof = BASE64_STANDARD.decode(equality_proof_base64).map_err(|e| {
            AppError::Validation(crate::domain::ValidationError::InvalidField {
                field: "equality_proof".to_string(),
                message: format!("Invalid base64 encoding: {}", e),
            })
        })?;

        let ciphertext_validity_proof = BASE64_STANDARD
            .decode(ciphertext_validity_proof_base64)
            .map_err(|e| {
                AppError::Validation(crate::domain::ValidationError::InvalidField {
                    field: "ciphertext_validity_proof".to_string(),
                    message: format!("Invalid base64 encoding: {}", e),
                })
            })?;

        let range_proof = BASE64_STANDARD.decode(range_proof_base64).map_err(|e| {
            AppError::Validation(crate::domain::ValidationError::InvalidField {
                field: "range_proof".to_string(),
                message: format!("Invalid base64 encoding: {}", e),
            })
        })?;

        debug!(
            balance_bytes = new_decryptable_balance.len(),
            equality_proof_bytes = equality_proof.len(),
            validity_proof_bytes = ciphertext_validity_proof.len(),
            range_proof_bytes = range_proof.len(),
            "Decoded confidential transfer proof components"
        );

        // Token-2022 program ID
        let token_program_id = spl_token_2022::id();

        // Derive source and destination confidential token accounts
        let source_ata = get_associated_token_address_with_program_id(
            &keypair.pubkey(),
            &mint_pubkey,
            &token_program_id,
        );
        let destination_ata = get_associated_token_address_with_program_id(
            &to_pubkey,
            &mint_pubkey,
            &token_program_id,
        );

        debug!(
            source_ata = %source_ata,
            destination_ata = %destination_ata,
            "Derived confidential token accounts"
        );

        // Get priority fee using provider-specific strategy
        let priority_fee = self.get_priority_fee(None).await;

        // ====================================================================
        // MULTI-TRANSACTION SPLIT PROOF VERIFICATION
        // ====================================================================
        // Token-2022 confidential transfers require 3 ZK proofs that are too
        // large to fit in a single transaction. We must:
        //
        // 1. Create context state accounts via the ZK ElGamal Proof Program
        // 2. Verify each proof in separate transactions
        // 3. Execute the transfer referencing the context accounts
        // 4. Close context accounts to recover rent
        //
        // Context state accounts are PDAs derived from:
        // - The context state authority (relayer's pubkey)
        // - A unique seed per proof type
        // ====================================================================

        info!("Step 1: Preparing verification transactions for ZK proofs");

        let zk_elgamal_proof_program = solana_zk_sdk::zk_elgamal_proof_program::id();
        let context_authority = keypair.pubkey();

        // ====================================================================
        // CREATE EPHEMERAL KEYPAIRS FOR CONTEXT STATE ACCOUNTS
        // ====================================================================
        // The ZK program needs regular accounts (NOT PDAs) to store verified
        // proof state. We create fresh keypairs for each transfer attempt.
        // These will be closed after the transfer to recover rent.

        let equality_context_keypair = Keypair::new();
        let validity_context_keypair = Keypair::new();
        let range_context_keypair = Keypair::new();

        let equality_context_pubkey = equality_context_keypair.pubkey();
        let validity_context_pubkey = validity_context_keypair.pubkey();
        let range_context_pubkey = range_context_keypair.pubkey();

        // Calculate rent-exempt minimum for context accounts
        // CiphertextCommitmentEquality context: ~128 bytes
        // BatchedGroupedCiphertext3HandlesValidity context: ~256 bytes
        // BatchedRangeProofU128 context: ~512 bytes
        const EQUALITY_CONTEXT_SIZE: u64 = 128;
        const VALIDITY_CONTEXT_SIZE: u64 = 256;
        const RANGE_CONTEXT_SIZE: u64 = 512;

        let equality_rent = sdk_client
            .get_minimum_balance_for_rent_exemption(EQUALITY_CONTEXT_SIZE as usize)
            .await
            .map_err(map_solana_client_error)?;
        let validity_rent = sdk_client
            .get_minimum_balance_for_rent_exemption(VALIDITY_CONTEXT_SIZE as usize)
            .await
            .map_err(map_solana_client_error)?;
        let range_rent = sdk_client
            .get_minimum_balance_for_rent_exemption(RANGE_CONTEXT_SIZE as usize)
            .await
            .map_err(map_solana_client_error)?;

        debug!(
            equality_ctx = %equality_context_pubkey,
            validity_ctx = %validity_context_pubkey,
            range_ctx = %range_context_pubkey,
            equality_rent = %equality_rent,
            validity_rent = %validity_rent,
            range_rent = %range_rent,
            "Created ephemeral context account keypairs"
        );

        // ====================================================================
        // TRANSACTION 1: Create Account + Verify Equality Proof
        // ====================================================================
        info!("Transaction 1: Verifying equality proof");

        // Step 1a: Create the context account FIRST
        let create_equality_ctx_ix = system_instruction::create_account(
            &keypair.pubkey(),         // payer
            &equality_context_pubkey,  // new account
            equality_rent,             // lamports for rent exemption
            EQUALITY_CONTEXT_SIZE,     // account size in bytes
            &zk_elgamal_proof_program, // owner = ZK program
        );

        // Step 1b: Build verify instruction using SDK enum for discriminator
        let equality_discriminator = ProofInstruction::VerifyCiphertextCommitmentEquality as u8;
        let mut equality_ix_data = vec![equality_discriminator];
        equality_ix_data.extend_from_slice(&equality_proof);

        let equality_verify_ix = Instruction {
            program_id: zk_elgamal_proof_program,
            accounts: vec![
                // Context state account (writable, already created above)
                solana_sdk::instruction::AccountMeta::new(equality_context_pubkey, false),
                // Context state authority (readonly, signer)
                solana_sdk::instruction::AccountMeta::new_readonly(context_authority, true),
            ],
            data: equality_ix_data,
        };

        let equality_tx_instructions = vec![
            ComputeBudgetInstruction::set_compute_unit_price(priority_fee),
            ComputeBudgetInstruction::set_compute_unit_limit(200_000),
            create_equality_ctx_ix, // CREATE first
            equality_verify_ix,     // VERIFY second
        ];

        let recent_blockhash = sdk_client
            .get_latest_blockhash()
            .await
            .map_err(map_solana_client_error)?;

        let equality_tx = Transaction::new_signed_with_payer(
            &equality_tx_instructions,
            Some(&keypair.pubkey()),
            &[keypair, &equality_context_keypair], // Context keypair must sign create_account
            recent_blockhash,
        );

        sdk_client
            .send_and_confirm_transaction(&equality_tx)
            .await
            .map_err(|e| {
                AppError::Blockchain(BlockchainError::TransactionFailed(format!(
                    "Equality proof verification failed: {}",
                    e
                )))
            })?;

        info!("Equality proof verified and context state created");

        // ====================================================================
        // TRANSACTION 2: Create Account + Verify Validity Proof
        // ====================================================================
        info!("Transaction 2: Verifying ciphertext validity proof");

        // Step 2a: Create the context account FIRST
        let create_validity_ctx_ix = system_instruction::create_account(
            &keypair.pubkey(),
            &validity_context_pubkey,
            validity_rent,
            VALIDITY_CONTEXT_SIZE,
            &zk_elgamal_proof_program,
        );

        // Step 2b: Build verify instruction
        let validity_discriminator =
            ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity as u8;
        let mut validity_ix_data = vec![validity_discriminator];
        validity_ix_data.extend_from_slice(&ciphertext_validity_proof);

        let validity_verify_ix = Instruction {
            program_id: zk_elgamal_proof_program,
            accounts: vec![
                solana_sdk::instruction::AccountMeta::new(validity_context_pubkey, false),
                solana_sdk::instruction::AccountMeta::new_readonly(context_authority, true),
            ],
            data: validity_ix_data,
        };

        let validity_tx_instructions = vec![
            ComputeBudgetInstruction::set_compute_unit_price(priority_fee),
            ComputeBudgetInstruction::set_compute_unit_limit(200_000),
            create_validity_ctx_ix, // CREATE first
            validity_verify_ix,     // VERIFY second
        ];

        let recent_blockhash = sdk_client
            .get_latest_blockhash()
            .await
            .map_err(map_solana_client_error)?;

        let validity_tx = Transaction::new_signed_with_payer(
            &validity_tx_instructions,
            Some(&keypair.pubkey()),
            &[keypair, &validity_context_keypair], // Context keypair must sign
            recent_blockhash,
        );

        sdk_client
            .send_and_confirm_transaction(&validity_tx)
            .await
            .map_err(|e| {
                AppError::Blockchain(BlockchainError::TransactionFailed(format!(
                    "Validity proof verification failed: {}",
                    e
                )))
            })?;

        info!("Validity proof verified and context state created");

        // ====================================================================
        // TRANSACTION 3: Create Account + Verify Range Proof
        // ====================================================================
        info!("Transaction 3: Verifying range proof");

        // Step 3a: Create the context account FIRST
        let create_range_ctx_ix = system_instruction::create_account(
            &keypair.pubkey(),
            &range_context_pubkey,
            range_rent,
            RANGE_CONTEXT_SIZE,
            &zk_elgamal_proof_program,
        );

        // Step 3b: Build verify instruction
        let range_discriminator = ProofInstruction::VerifyBatchedRangeProofU128 as u8;
        let mut range_ix_data = vec![range_discriminator];
        range_ix_data.extend_from_slice(&range_proof);

        let range_verify_ix = Instruction {
            program_id: zk_elgamal_proof_program,
            accounts: vec![
                solana_sdk::instruction::AccountMeta::new(range_context_pubkey, false),
                solana_sdk::instruction::AccountMeta::new_readonly(context_authority, true),
            ],
            data: range_ix_data,
        };

        let range_tx_instructions = vec![
            ComputeBudgetInstruction::set_compute_unit_price(priority_fee),
            ComputeBudgetInstruction::set_compute_unit_limit(1_200_000), // Range proofs need more compute!
            create_range_ctx_ix,                                         // CREATE first
            range_verify_ix,                                             // VERIFY second
        ];

        let recent_blockhash = sdk_client
            .get_latest_blockhash()
            .await
            .map_err(map_solana_client_error)?;

        let range_tx = Transaction::new_signed_with_payer(
            &range_tx_instructions,
            Some(&keypair.pubkey()),
            &[keypair, &range_context_keypair], // Context keypair must sign
            recent_blockhash,
        );

        sdk_client
            .send_and_confirm_transaction(&range_tx)
            .await
            .map_err(|e| {
                AppError::Blockchain(BlockchainError::TransactionFailed(format!(
                    "Range proof verification failed: {}",
                    e
                )))
            })?;

        info!("Range proof verified and context state created");

        // ====================================================================
        // TRANSACTION 4: Execute Transfer with Context Account References
        // ====================================================================
        info!("Transaction 4: Executing confidential transfer");

        // Check if destination ATA exists, create if needed
        let dest_account_result = sdk_client.get_account(&destination_ata).await;
        let mut transfer_instructions: Vec<Instruction> = vec![
            ComputeBudgetInstruction::set_compute_unit_price(priority_fee),
            ComputeBudgetInstruction::set_compute_unit_limit(400_000),
        ];

        if dest_account_result.is_err() {
            info!(destination_ata = %destination_ata, "Creating destination ATA");
            let create_ata_ix = create_associated_token_account_idempotent(
                &keypair.pubkey(),
                &to_pubkey,
                &mint_pubkey,
                &token_program_id,
            );
            transfer_instructions.push(create_ata_ix);
        }

        // ====================================================================
        // BUILD CONFIDENTIAL TRANSFER INSTRUCTION
        // ====================================================================
        // Token-2022 extension instruction format:
        //   Byte 0: TokenInstruction discriminator (we use the extension approach)
        //   Remaining: Extension-specific data
        //
        // For confidential transfer with split proofs, we use:
        //   [26] = ConfidentialTransferExtension (Token-2022 extension instruction)
        //   [7]  = Transfer (sub-instruction within confidential transfer)
        //
        // Account order per SPL Token-2022 ConfidentialTransferInstruction::Transfer spec:
        //   0. [writable] Source token account
        //   1. []         Token mint
        //   2. [writable] Destination token account
        //   3. []         Equality proof context account
        //   4. []         Ciphertext validity proof context account
        //   5. []         Range proof context account
        //   6. [signer]   Authority (owner of source account)

        // Build instruction data: [extension_discriminator | sub_instruction | transfer_data]
        let mut instruction_data = Vec::new();
        instruction_data.push(26u8); // ConfidentialTransferExtension
        instruction_data.push(7u8); // Transfer sub-instruction
        instruction_data.extend_from_slice(&new_decryptable_balance);

        let transfer_ix = Instruction {
            program_id: token_program_id,
            accounts: vec![
                // 0. Source token account (writable)
                solana_sdk::instruction::AccountMeta::new(source_ata, false),
                // 1. Mint (readonly)
                solana_sdk::instruction::AccountMeta::new_readonly(mint_pubkey, false),
                // 2. Destination token account (writable)
                solana_sdk::instruction::AccountMeta::new(destination_ata, false),
                // 3. Equality proof context (readonly) - pre-verified
                solana_sdk::instruction::AccountMeta::new_readonly(equality_context_pubkey, false),
                // 4. Ciphertext validity proof context (readonly)
                solana_sdk::instruction::AccountMeta::new_readonly(validity_context_pubkey, false),
                // 5. Range proof context (readonly)
                solana_sdk::instruction::AccountMeta::new_readonly(range_context_pubkey, false),
                // 6. Authority (signer) - owner of source account
                solana_sdk::instruction::AccountMeta::new_readonly(keypair.pubkey(), true),
            ],
            data: instruction_data,
        };

        transfer_instructions.push(transfer_ix);

        let recent_blockhash = sdk_client
            .get_latest_blockhash()
            .await
            .map_err(map_solana_client_error)?;

        let transfer_tx = Transaction::new_signed_with_payer(
            &transfer_instructions,
            Some(&keypair.pubkey()),
            &[keypair],
            recent_blockhash,
        );

        info!("Sending confidential transfer transaction");

        let signature = sdk_client
            .send_and_confirm_transaction(&transfer_tx)
            .await
            .map_err(|e| {
                let msg = e.to_string();
                if msg.contains("ProofVerificationFailed") || msg.contains("proof") {
                    AppError::Blockchain(BlockchainError::TransactionFailed(format!(
                        "ZK proof verification failed: {}",
                        msg
                    )))
                } else if msg.contains("ConfidentialTransferNotEnabled") {
                    AppError::Blockchain(BlockchainError::TransactionFailed(format!(
                        "Mint does not have confidential transfer extension enabled: {}",
                        msg
                    )))
                } else {
                    map_solana_client_error(e)
                }
            })?;

        info!(
            signature = %signature,
            to = %to_address,
            token_mint = %token_mint,
            "Confidential transfer with split proofs completed successfully"
        );

        Ok(signature.to_string())
    }

    #[instrument(skip(self))]
    async fn get_block_height(&self) -> Result<u64, AppError> {
        self.rpc_call("getBlockHeight", Vec::<()>::new()).await
    }

    #[instrument(skip(self))]
    async fn get_latest_blockhash(&self) -> Result<String, AppError> {
        let result: BlockhashResult = self
            .rpc_call("getLatestBlockhash", Vec::<()>::new())
            .await?;
        Ok(result.value.blockhash)
    }

    #[instrument(skip(self))]
    async fn get_transaction_status(&self, signature: &str) -> Result<bool, AppError> {
        let params = serde_json::json!([[signature], {"searchTransactionHistory": true}]);
        let result: SignatureStatusResult = self.rpc_call("getSignatureStatuses", params).await?;

        match result.value.first() {
            Some(Some(status)) => {
                // Check if transaction errored
                if status.err.is_some() {
                    return Err(AppError::Blockchain(BlockchainError::TransactionFailed(
                        format!("Transaction failed: {:?}", status.err),
                    )));
                }
                // Check confirmation status
                let confirmed = status.confirmation_status.as_deref() == Some("confirmed")
                    || status.confirmation_status.as_deref() == Some("finalized");
                Ok(confirmed)
            }
            _ => Ok(false),
        }
    }

    #[instrument(skip(self))]
    async fn wait_for_confirmation(
        &self,
        signature: &str,
        timeout_secs: u64,
    ) -> Result<bool, AppError> {
        let timeout = Duration::from_secs(timeout_secs);
        let start = std::time::Instant::now();
        let poll_interval = Duration::from_millis(500);

        while start.elapsed() < timeout {
            match self.get_transaction_status(signature).await {
                Ok(true) => {
                    info!(signature = %signature, "Transaction confirmed");
                    return Ok(true);
                }
                Ok(false) => {
                    debug!(signature = %signature, "Transaction not yet confirmed");
                }
                Err(AppError::Blockchain(BlockchainError::TransactionFailed(msg))) => {
                    return Err(AppError::Blockchain(BlockchainError::TransactionFailed(
                        msg,
                    )));
                }
                Err(e) => {
                    warn!(signature = %signature, error = ?e, "Error checking transaction status");
                }
            }
            tokio::time::sleep(poll_interval).await;
        }

        Err(AppError::Blockchain(BlockchainError::Timeout(format!(
            "Transaction {} not confirmed within {}s",
            signature, timeout_secs
        ))))
    }

    #[instrument(skip(self))]
    async fn transfer_sol(
        &self,
        to_address: &str,
        amount_lamports: u64,
    ) -> Result<String, AppError> {
        info!(to = %to_address, amount_lamports = %amount_lamports, "Transferring SOL");

        // Validate amount
        if amount_lamports == 0 {
            return Err(AppError::Blockchain(BlockchainError::TransactionFailed(
                "Transfer amount must be greater than 0".to_string(),
            )));
        }

        // Check if we have SDK client and keypair
        let (sdk_client, keypair) = match (&self.sdk_client, &self.keypair) {
            (Some(client), Some(kp)) => (client, kp),
            _ => {
                return Err(AppError::Blockchain(BlockchainError::TransactionFailed(
                    "SDK client not initialized for SOL transfers".to_string(),
                )));
            }
        };

        // Parse destination address
        let to_pubkey = to_address.parse::<Pubkey>().map_err(|e| {
            AppError::Blockchain(BlockchainError::InvalidSignature(format!(
                "Invalid destination address: {}",
                e
            )))
        })?;

        // Get priority fee using provider-specific strategy
        let priority_fee = self.get_priority_fee(None).await;

        // Create transfer instruction using SDK
        let transfer_ix =
            system_instruction::transfer(&keypair.pubkey(), &to_pubkey, amount_lamports);

        // Build instructions with compute budget for priority fee
        let instructions = vec![
            ComputeBudgetInstruction::set_compute_unit_price(priority_fee),
            transfer_ix,
        ];

        // Get recent blockhash using SDK
        let recent_blockhash = sdk_client
            .get_latest_blockhash()
            .await
            .map_err(map_solana_client_error)?;

        // Build and sign transaction
        let transaction = Transaction::new_signed_with_payer(
            &instructions,
            Some(&keypair.pubkey()),
            &[keypair],
            recent_blockhash,
        );

        // Send and confirm transaction
        let signature = sdk_client
            .send_and_confirm_transaction(&transaction)
            .await
            .map_err(map_solana_client_error)?;

        info!(signature = %signature, to = %to_address, amount_lamports = %amount_lamports, "SOL transfer submitted via SDK");

        Ok(signature.to_string())
    }

    #[instrument(skip(self))]
    async fn transfer_token(
        &self,
        to_address: &str,
        token_mint: &str,
        amount: u64,
    ) -> Result<String, AppError> {
        info!(to = %to_address, token_mint = %token_mint, amount = %amount, "Transferring SPL Token (raw units)");

        // Validate amount
        if amount == 0 {
            return Err(AppError::Blockchain(BlockchainError::TransactionFailed(
                "Transfer amount must be greater than 0".to_string(),
            )));
        }

        // Check if we have SDK client and keypair
        let (sdk_client, keypair) = match (&self.sdk_client, &self.keypair) {
            (Some(client), Some(kp)) => (client, kp),
            _ => {
                return Err(AppError::Blockchain(BlockchainError::TransactionFailed(
                    "SDK client not initialized for token transfers".to_string(),
                )));
            }
        };

        // Parse addresses
        let to_pubkey = to_address.parse::<Pubkey>().map_err(|e| {
            AppError::Blockchain(BlockchainError::InvalidSignature(format!(
                "Invalid destination address: {}",
                e
            )))
        })?;

        let mint_pubkey = token_mint.parse::<Pubkey>().map_err(|e| {
            AppError::Blockchain(BlockchainError::InvalidSignature(format!(
                "Invalid token mint address: {}",
                e
            )))
        })?;

        // Fetch the mint account to determine the correct token program ID and decimals
        // This is required for transfer_checked instruction (validates decimals) and Token-2022 support
        let mint_account = sdk_client.get_account(&mint_pubkey).await.map_err(|e| {
            AppError::Blockchain(BlockchainError::TransactionFailed(format!(
                "Failed to fetch mint account: {}",
                e
            )))
        })?;

        // The mint account's owner is the token program ID
        let token_program_id = mint_account.owner;
        debug!(token_program_id = %token_program_id, "Detected token program from mint");

        // Extract decimals from mint account data (required for transfer_checked)
        // Mint layout (both SPL Token and Token-2022):
        // - bytes 0-35: mint_authority option (1 byte option flag + up to 32 bytes pubkey)
        // - bytes 36-43: supply (u64)
        // - byte 44: decimals (u8)
        // - byte 45: is_initialized (bool)
        // - bytes 46-78: freeze_authority option
        const DECIMALS_OFFSET: usize = 44;
        const MIN_MINT_SIZE: usize = 82;

        if mint_account.data.len() < MIN_MINT_SIZE {
            return Err(AppError::Blockchain(BlockchainError::TransactionFailed(
                format!(
                    "Mint account data too small: {} bytes, expected at least {}",
                    mint_account.data.len(),
                    MIN_MINT_SIZE
                ),
            )));
        }

        let decimals = mint_account.data[DECIMALS_OFFSET];
        debug!(decimals = %decimals, "Read decimals from mint account (needed for transfer_checked)");

        // Derive Associated Token Accounts with the correct token program ID
        let source_ata = get_associated_token_address_with_program_id(
            &keypair.pubkey(),
            &mint_pubkey,
            &token_program_id,
        );
        let destination_ata = get_associated_token_address_with_program_id(
            &to_pubkey,
            &mint_pubkey,
            &token_program_id,
        );

        debug!(
            source_ata = %source_ata,
            destination_ata = %destination_ata,
            token_program_id = %token_program_id,
            "Derived ATAs for token transfer"
        );

        // CRITICAL: Verify source ATA exists and has sufficient balance
        let source_account = sdk_client.get_account(&source_ata).await.map_err(|e| {
            AppError::Blockchain(BlockchainError::TransactionFailed(format!(
                "Source token account does not exist or cannot be fetched. \
                 The sender ({}) does not have an associated token account for mint {}. \
                 Error: {}",
                keypair.pubkey(),
                token_mint,
                e
            )))
        })?;

        // Verify the source account is owned by the token program
        if source_account.owner != token_program_id {
            return Err(AppError::Blockchain(BlockchainError::TransactionFailed(
                format!(
                    "Source token account is not owned by the token program. \
                     Expected owner: {}, actual owner: {}",
                    token_program_id, source_account.owner
                ),
            )));
        }

        // Extract balance from token account data to verify sufficient funds
        // Token account layout: amount is at bytes 64-72 (u64 LE)
        const TOKEN_ACCOUNT_AMOUNT_OFFSET: usize = 64;
        if source_account.data.len() >= TOKEN_ACCOUNT_AMOUNT_OFFSET + 8 {
            let balance_bytes: [u8; 8] = source_account.data
                [TOKEN_ACCOUNT_AMOUNT_OFFSET..TOKEN_ACCOUNT_AMOUNT_OFFSET + 8]
                .try_into()
                .unwrap();
            let balance = u64::from_le_bytes(balance_bytes);
            debug!(source_balance = %balance, required = %amount, "Checking source token balance");

            if balance < amount {
                return Err(AppError::Blockchain(BlockchainError::InsufficientFunds));
            }
        }

        // Get priority fee using provider-specific strategy
        let priority_fee = self.get_priority_fee(None).await;

        // Start with compute budget instruction for priority fee
        let mut instructions: Vec<Instruction> =
            vec![ComputeBudgetInstruction::set_compute_unit_price(
                priority_fee,
            )];

        // Check if destination ATA exists
        let dest_account_result = sdk_client.get_account(&destination_ata).await;

        if dest_account_result.is_err() {
            // ATA doesn't exist - create it using idempotent instruction
            // This is safer as it won't fail if the ATA gets created between our check and execution
            info!(destination_ata = %destination_ata, "Creating destination ATA");
            let create_ata_ix = create_associated_token_account_idempotent(
                &keypair.pubkey(), // payer
                &to_pubkey,        // wallet owner
                &mint_pubkey,      // token mint
                &token_program_id, // token program (dynamically detected)
            );
            instructions.push(create_ata_ix);
        }

        // Create SPL Token transfer_checked instruction for safer transfers
        // transfer_checked validates the mint and decimals, providing better error messages
        // Note: We pass the raw `amount` directly (already in token units), but still need
        // `decimals` for the transfer_checked instruction validation
        let transfer_ix = token_instruction::transfer_checked(
            &token_program_id,
            &source_ata,
            &mint_pubkey,
            &destination_ata,
            &keypair.pubkey(), // authority (owner of source account)
            &[],               // no multisig signers
            amount,            // already in raw token units
            decimals,          // required by transfer_checked for validation
        )
        .map_err(|e| {
            AppError::Blockchain(BlockchainError::TransactionFailed(format!(
                "Failed to create transfer_checked instruction: {}",
                e
            )))
        })?;

        instructions.push(transfer_ix);

        // Get recent blockhash
        let recent_blockhash = sdk_client
            .get_latest_blockhash()
            .await
            .map_err(map_solana_client_error)?;

        // Build and sign transaction
        let transaction = Transaction::new_signed_with_payer(
            &instructions,
            Some(&keypair.pubkey()),
            &[keypair],
            recent_blockhash,
        );

        // Send and confirm transaction
        let signature = sdk_client
            .send_and_confirm_transaction(&transaction)
            .await
            .map_err(map_solana_client_error)?;

        info!(
            signature = %signature,
            to = %to_address,
            token_mint = %token_mint,
            amount = %amount,
            decimals = %decimals,
            "SPL Token transfer submitted (raw units)"
        );

        Ok(signature.to_string())
    }

    /// Check if a wallet holds compliant assets using Helius DAS.
    ///
    /// This method checks if the wallet holds any assets from sanctioned collections.
    /// It is only available when using a Helius RPC provider.
    ///
    /// # Behavior by Provider
    /// - **Helius**: Uses `getAssetsByOwner` DAS API to check asset collections
    /// - **QuickNode/Standard**: Returns `true` (skip check, assume compliant)
    ///
    /// # Arguments
    /// * `owner` - The wallet address (Base58) to check
    ///
    /// # Returns
    /// * `Ok(true)` - Wallet is compliant (no sanctioned assets or DAS not available)
    /// * `Ok(false)` - Wallet holds sanctioned assets
    /// * `Err(_)` - API error during check
    #[instrument(skip(self))]
    async fn check_wallet_assets(&self, owner: &str) -> Result<bool, AppError> {
        match &self.das_client {
            Some(das_client) => {
                info!(wallet = %owner, "Helius DAS Check: Initiating asset scan");
                das_client.check_wallet_compliance(owner).await
            }
            None => {
                debug!(
                    wallet = %owner,
                    provider = %self.provider_type.name(),
                    "DAS not available for this provider, skipping asset check"
                );
                Ok(true)
            }
        }
    }
}

/// Map Solana client errors to our AppError types
fn map_solana_client_error(err: solana_client::client_error::ClientError) -> AppError {
    use solana_client::client_error::ClientErrorKind;

    let msg = err.to_string();

    match err.kind() {
        ClientErrorKind::RpcError(_) => {
            if msg.contains("insufficient") || msg.contains("InsufficientFunds") {
                AppError::Blockchain(BlockchainError::InsufficientFunds)
            } else {
                AppError::Blockchain(BlockchainError::RpcError(msg))
            }
        }
        ClientErrorKind::Io(_) => AppError::Blockchain(BlockchainError::Connection(msg)),
        ClientErrorKind::Reqwest(_) => {
            if msg.contains("timeout") || msg.contains("timed out") {
                AppError::Blockchain(BlockchainError::Timeout(msg))
            } else {
                AppError::Blockchain(BlockchainError::Connection(msg))
            }
        }
        _ => AppError::Blockchain(BlockchainError::TransactionFailed(msg)),
    }
}

/// Parse a base58-encoded private key into a SigningKey
pub fn signing_key_from_base58(secret: &SecretString) -> Result<SigningKey, AppError> {
    let key_bytes = bs58::decode(secret.expose_secret())
        .into_vec()
        .map_err(|e| AppError::Blockchain(BlockchainError::InvalidSignature(e.to_string())))?;

    // Handle both 32-byte (seed) and 64-byte (keypair) formats
    let key_array: [u8; 32] = if key_bytes.len() == 64 {
        // Solana keypair format: first 32 bytes are the secret key
        key_bytes[..32].try_into().map_err(|_| {
            AppError::Blockchain(BlockchainError::InvalidSignature(
                "Invalid keypair format".to_string(),
            ))
        })?
    } else if key_bytes.len() == 32 {
        key_bytes.try_into().map_err(|v: Vec<u8>| {
            AppError::Blockchain(BlockchainError::InvalidSignature(format!(
                "Key must be 32 bytes, got {}",
                v.len()
            )))
        })?
    } else {
        return Err(AppError::Blockchain(BlockchainError::InvalidSignature(
            format!("Key must be 32 or 64 bytes, got {}", key_bytes.len()),
        )));
    };

    Ok(SigningKey::from_bytes(&key_array))
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::rngs::OsRng;

    #[test]
    fn test_client_creation() {
        let signing_key = SigningKey::generate(&mut OsRng);
        let client =
            RpcBlockchainClient::with_defaults("https://api.devnet.solana.com", signing_key);
        assert!(client.is_ok());
    }

    #[test]
    fn test_public_key_generation() {
        let signing_key = SigningKey::generate(&mut OsRng);
        let client =
            RpcBlockchainClient::with_defaults("https://api.devnet.solana.com", signing_key)
                .unwrap();
        let pubkey = client.public_key();
        assert!(!pubkey.is_empty());
        // Verify it decodes to 32 bytes (length can be 43 or 44 chars)
        let decoded = bs58::decode(&pubkey)
            .into_vec()
            .expect("Should be valid base58");
        assert_eq!(decoded.len(), 32);
    }

    #[test]
    fn test_signing() {
        let signing_key = SigningKey::generate(&mut OsRng);
        let client =
            RpcBlockchainClient::with_defaults("https://api.devnet.solana.com", signing_key)
                .unwrap();
        let signature = client.sign(b"test message");
        assert!(!signature.is_empty());
    }

    #[test]
    fn test_signing_key_from_base58_valid_32_bytes() {
        let original_key = SigningKey::generate(&mut OsRng);
        let encoded = bs58::encode(original_key.to_bytes()).into_string();
        let secret = SecretString::from(encoded);
        let result = signing_key_from_base58(&secret);
        assert!(result.is_ok());
    }

    #[test]
    fn test_signing_key_from_base58_valid_64_bytes() {
        let original_key = SigningKey::generate(&mut OsRng);
        let mut keypair = original_key.to_bytes().to_vec();
        keypair.extend_from_slice(original_key.verifying_key().as_bytes());
        let encoded = bs58::encode(&keypair).into_string();
        let secret = SecretString::from(encoded);
        let result = signing_key_from_base58(&secret);
        assert!(result.is_ok());
    }

    #[test]
    fn test_signing_key_from_base58_invalid() {
        let secret = SecretString::from("invalid-base58!!!");
        let result = signing_key_from_base58(&secret);
        assert!(result.is_err());
    }

    #[test]
    fn test_rpc_client_config_default() {
        let config = RpcClientConfig::default();
        assert_eq!(config.max_retries, 3);
        assert_eq!(config.timeout, Duration::from_secs(30));
        assert_eq!(config.confirmation_timeout, Duration::from_secs(60));
    }

    #[test]
    fn test_signing_key_from_base58_wrong_length() {
        // 16 bytes - too short
        let short_key = bs58::encode(vec![0u8; 16]).into_string();
        let secret = SecretString::from(short_key);
        let result = signing_key_from_base58(&secret);
        assert!(result.is_err());

        // 48 bytes - wrong size (not 32 or 64)
        let wrong_key = bs58::encode(vec![0u8; 48]).into_string();
        let secret = SecretString::from(wrong_key);
        let result = signing_key_from_base58(&secret);
        assert!(result.is_err());
    }

    #[test]
    fn test_rpc_client_config_custom() {
        let config = RpcClientConfig {
            timeout: Duration::from_secs(60),
            max_retries: 5,
            retry_delay: Duration::from_millis(1000),
            confirmation_timeout: Duration::from_secs(120),
        };
        assert_eq!(config.timeout, Duration::from_secs(60));
        assert_eq!(config.max_retries, 5);
        assert_eq!(config.retry_delay, Duration::from_millis(1000));
        assert_eq!(config.confirmation_timeout, Duration::from_secs(120));
    }

    #[test]
    fn test_signing_determinism() {
        let signing_key = SigningKey::generate(&mut OsRng);
        let client =
            RpcBlockchainClient::with_defaults("https://api.devnet.solana.com", signing_key)
                .unwrap();

        // Same message should produce same signature
        let sig1 = client.sign(b"test message");
        let sig2 = client.sign(b"test message");
        assert_eq!(sig1, sig2);

        // Different message should produce different signature
        let sig3 = client.sign(b"different message");
        assert_ne!(sig1, sig3);
    }

    // --- MOCK PROVIDER TESTS ---
    use std::sync::Mutex;

    #[cfg(test)]
    #[allow(dead_code)]
    enum BlockchainErrorType {
        Timeout,
        Rpc,
    }

    struct MockState {
        requests: Vec<String>,
        should_fail_count: u32,
        failure_error: Option<BlockchainErrorType>,
        next_response: Option<serde_json::Value>,
    }

    struct MockSolanaRpcProvider {
        state: Mutex<MockState>,
        signing_key: SigningKey,
    }

    impl MockSolanaRpcProvider {
        fn new() -> Self {
            Self {
                state: Mutex::new(MockState {
                    requests: Vec::new(),
                    should_fail_count: 0,
                    failure_error: None,
                    next_response: None,
                }),
                signing_key: SigningKey::generate(&mut OsRng),
            }
        }

        fn with_failure(count: u32, error_type: BlockchainErrorType) -> Self {
            let provider = Self::new(); // removed `mut` since we don’t mutate `provider` itself
            {
                let mut state = provider.state.lock().unwrap();
                state.should_fail_count = count;
                state.failure_error = Some(error_type);
            }
            provider
        }
    }

    #[async_trait]
    impl SolanaRpcProvider for MockSolanaRpcProvider {
        async fn send_request(
            &self,
            method: &str,
            _params: serde_json::Value,
        ) -> Result<serde_json::Value, AppError> {
            let mut state = self.state.lock().unwrap();
            state.requests.push(method.to_string());

            if state.should_fail_count > 0 {
                state.should_fail_count -= 1;
                if let Some(ref err) = state.failure_error {
                    return match err {
                        BlockchainErrorType::Timeout => Err(AppError::Blockchain(
                            BlockchainError::Timeout("Mock timeout".to_string()),
                        )),
                        BlockchainErrorType::Rpc => Err(AppError::Blockchain(
                            BlockchainError::RpcError("Mock RPC error".to_string()),
                        )),
                    };
                }
            }

            if let Some(resp) = &state.next_response {
                return Ok(resp.clone());
            }

            Ok(serde_json::Value::Null)
        }

        fn public_key(&self) -> String {
            bs58::encode(self.signing_key.verifying_key().as_bytes()).into_string()
        }

        fn sign(&self, message: &[u8]) -> String {
            let signature = self.signing_key.sign(message);
            bs58::encode(signature.to_bytes()).into_string()
        }
    }

    #[tokio::test]
    async fn test_rpc_client_retry_logic_success() {
        // Setup provider that fails twice then succeeds
        let provider = MockSolanaRpcProvider::with_failure(2, BlockchainErrorType::Timeout);
        let config = RpcClientConfig {
            max_retries: 3,
            retry_delay: Duration::from_millis(1), // Fast retry
            ..Default::default()
        };

        // Set success response
        {
            let mut state = provider.state.lock().unwrap();
            state.next_response = Some(serde_json::json!(12345u64)); // Slot response
        }

        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        // Call health_check (uses getSlot)
        let result = client.health_check().await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_rpc_client_retry_logic_failure() {
        // Setup provider that fails 4 times (max retries is 3)
        let provider = MockSolanaRpcProvider::with_failure(4, BlockchainErrorType::Timeout);
        let config = RpcClientConfig {
            max_retries: 3,
            retry_delay: Duration::from_millis(1),
            ..Default::default()
        };

        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.health_check().await;
        assert!(matches!(
            result,
            Err(AppError::Blockchain(BlockchainError::Timeout(_)))
        ));
    }

    // --- ENHANCED MOCK FOR ERROR SCENARIOS ---

    #[derive(Clone)]
    #[allow(dead_code)]
    enum MockErrorKind {
        Timeout(String),
        RpcError(String),
        InsufficientFunds,
        TransactionFailed(String),
        EmptyResponse,
    }

    struct ConfigurableMockProvider {
        signing_key: SigningKey,
        responses: Mutex<Vec<Result<serde_json::Value, MockErrorKind>>>,
        call_count: Mutex<usize>,
    }

    impl ConfigurableMockProvider {
        fn new() -> Self {
            Self {
                signing_key: SigningKey::generate(&mut OsRng),
                responses: Mutex::new(Vec::new()),
                call_count: Mutex::new(0),
            }
        }

        fn with_responses(responses: Vec<Result<serde_json::Value, MockErrorKind>>) -> Self {
            let provider = Self::new();
            *provider.responses.lock().unwrap() = responses;
            provider
        }

        #[allow(dead_code)]
        fn get_call_count(&self) -> usize {
            *self.call_count.lock().unwrap()
        }
    }

    #[async_trait]
    impl SolanaRpcProvider for ConfigurableMockProvider {
        async fn send_request(
            &self,
            _method: &str,
            _params: serde_json::Value,
        ) -> Result<serde_json::Value, AppError> {
            let mut count = self.call_count.lock().unwrap();
            let idx = *count;
            *count += 1;
            drop(count);

            let responses = self.responses.lock().unwrap();
            if idx < responses.len() {
                match &responses[idx] {
                    Ok(v) => Ok(v.clone()),
                    Err(MockErrorKind::Timeout(msg)) => {
                        Err(AppError::Blockchain(BlockchainError::Timeout(msg.clone())))
                    }
                    Err(MockErrorKind::RpcError(msg)) => {
                        Err(AppError::Blockchain(BlockchainError::RpcError(msg.clone())))
                    }
                    Err(MockErrorKind::InsufficientFunds) => {
                        Err(AppError::Blockchain(BlockchainError::InsufficientFunds))
                    }
                    Err(MockErrorKind::TransactionFailed(msg)) => Err(AppError::Blockchain(
                        BlockchainError::TransactionFailed(msg.clone()),
                    )),
                    Err(MockErrorKind::EmptyResponse) => Err(AppError::Blockchain(
                        BlockchainError::RpcError("Empty response".to_string()),
                    )),
                }
            } else {
                Ok(serde_json::Value::Null)
            }
        }

        fn public_key(&self) -> String {
            bs58::encode(self.signing_key.verifying_key().as_bytes()).into_string()
        }

        fn sign(&self, message: &[u8]) -> String {
            let signature = self.signing_key.sign(message);
            bs58::encode(signature.to_bytes()).into_string()
        }
    }

    // --- ERROR HANDLING TESTS ---

    #[tokio::test]
    async fn test_rpc_error_insufficient_funds() {
        let provider =
            ConfigurableMockProvider::with_responses(vec![Err(MockErrorKind::InsufficientFunds)]);
        let config = RpcClientConfig {
            max_retries: 0, // No retries for this test
            ..Default::default()
        };
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.health_check().await;
        assert!(matches!(
            result,
            Err(AppError::Blockchain(BlockchainError::InsufficientFunds))
        ));
    }

    #[tokio::test]
    async fn test_rpc_error_timeout_mapping() {
        let provider = ConfigurableMockProvider::with_responses(vec![Err(MockErrorKind::Timeout(
            "Connection timed out".to_string(),
        ))]);
        let config = RpcClientConfig {
            max_retries: 0,
            ..Default::default()
        };
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.health_check().await;
        match result {
            Err(AppError::Blockchain(BlockchainError::Timeout(msg))) => {
                assert!(msg.contains("timed out"));
            }
            _ => panic!("Expected timeout error"),
        }
    }

    #[tokio::test]
    async fn test_rpc_error_generic_rpc_error() {
        let provider = ConfigurableMockProvider::with_responses(vec![Err(
            MockErrorKind::RpcError("-32000: Server is busy".to_string()),
        )]);
        let config = RpcClientConfig {
            max_retries: 0,
            ..Default::default()
        };
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.health_check().await;
        match result {
            Err(AppError::Blockchain(BlockchainError::RpcError(msg))) => {
                assert!(msg.contains("Server is busy"));
            }
            _ => panic!("Expected RPC error"),
        }
    }

    // --- DESERIALIZATION TESTS ---

    #[test]
    fn test_deserialize_signature_status_confirmed() {
        let json = serde_json::json!({
            "err": null,
            "confirmationStatus": "confirmed"
        });
        let status: SignatureStatus = serde_json::from_value(json).unwrap();
        assert!(status.err.is_none());
        assert_eq!(status.confirmation_status.as_deref(), Some("confirmed"));
    }

    #[test]
    fn test_deserialize_signature_status_finalized() {
        let json = serde_json::json!({
            "err": null,
            "confirmationStatus": "finalized"
        });
        let status: SignatureStatus = serde_json::from_value(json).unwrap();
        assert!(status.err.is_none());
        assert_eq!(status.confirmation_status.as_deref(), Some("finalized"));
    }

    #[test]
    fn test_deserialize_signature_status_with_error() {
        let json = serde_json::json!({
            "err": {"InstructionError": [0, "Custom"]},
            "confirmationStatus": "confirmed"
        });
        let status: SignatureStatus = serde_json::from_value(json).unwrap();
        assert!(status.err.is_some());
    }

    #[test]
    fn test_deserialize_signature_status_null_confirmation() {
        let json = serde_json::json!({
            "err": null,
            "confirmationStatus": null
        });
        let status: SignatureStatus = serde_json::from_value(json).unwrap();
        assert!(status.confirmation_status.is_none());
    }

    #[test]
    fn test_deserialize_blockhash_result() {
        let json = serde_json::json!({
            "value": {
                "blockhash": "GHtXQBsoZHVnNFa9YevAzFr17DJjgHXk3ycTy5nRhVT3"
            }
        });
        let result: BlockhashResult = serde_json::from_value(json).unwrap();
        assert_eq!(
            result.value.blockhash,
            "GHtXQBsoZHVnNFa9YevAzFr17DJjgHXk3ycTy5nRhVT3"
        );
    }

    #[test]
    fn test_deserialize_signature_status_result() {
        let json = serde_json::json!({
            "value": [
                {
                    "err": null,
                    "confirmationStatus": "finalized"
                }
            ]
        });
        let result: SignatureStatusResult = serde_json::from_value(json).unwrap();
        assert_eq!(result.value.len(), 1);
        assert!(result.value[0].is_some());
    }

    #[test]
    fn test_deserialize_signature_status_result_null_entry() {
        let json = serde_json::json!({
            "value": [null]
        });
        let result: SignatureStatusResult = serde_json::from_value(json).unwrap();
        assert_eq!(result.value.len(), 1);
        assert!(result.value[0].is_none());
    }

    // --- TRANSACTION STATUS TESTS ---

    #[tokio::test]
    async fn test_get_transaction_status_confirmed() {
        let provider = ConfigurableMockProvider::with_responses(vec![Ok(serde_json::json!({
            "value": [{
                "err": null,
                "confirmationStatus": "confirmed"
            }]
        }))]);
        let config = RpcClientConfig::default();
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.get_transaction_status("test_sig").await;
        assert!(result.is_ok());
        assert!(result.unwrap()); // Should be confirmed
    }

    #[tokio::test]
    async fn test_get_transaction_status_finalized() {
        let provider = ConfigurableMockProvider::with_responses(vec![Ok(serde_json::json!({
            "value": [{
                "err": null,
                "confirmationStatus": "finalized"
            }]
        }))]);
        let config = RpcClientConfig::default();
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.get_transaction_status("test_sig").await;
        assert!(result.is_ok());
        assert!(result.unwrap());
    }

    #[tokio::test]
    async fn test_get_transaction_status_not_found() {
        let provider = ConfigurableMockProvider::with_responses(vec![Ok(serde_json::json!({
            "value": [null]
        }))]);
        let config = RpcClientConfig::default();
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.get_transaction_status("unknown_sig").await;
        assert!(result.is_ok());
        assert!(!result.unwrap()); // Not found = not confirmed
    }

    #[tokio::test]
    async fn test_get_transaction_status_with_error() {
        let provider = ConfigurableMockProvider::with_responses(vec![Ok(serde_json::json!({
            "value": [{
                "err": {"InstructionError": [0, "Custom"]},
                "confirmationStatus": "confirmed"
            }]
        }))]);
        let config = RpcClientConfig::default();
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.get_transaction_status("failed_sig").await;
        assert!(matches!(
            result,
            Err(AppError::Blockchain(BlockchainError::TransactionFailed(_)))
        ));
    }

    // --- BLOCKHASH AND BLOCK HEIGHT TESTS ---

    #[tokio::test]
    async fn test_get_latest_blockhash() {
        let provider = ConfigurableMockProvider::with_responses(vec![Ok(serde_json::json!({
            "value": {
                "blockhash": "TestBlockhash123"
            }
        }))]);
        let config = RpcClientConfig::default();
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.get_latest_blockhash().await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "TestBlockhash123");
    }

    #[tokio::test]
    async fn test_get_block_height() {
        let provider =
            ConfigurableMockProvider::with_responses(vec![Ok(serde_json::json!(123456789u64))]);
        let config = RpcClientConfig::default();
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.get_block_height().await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 123456789);
    }

    // --- WAIT FOR CONFIRMATION TESTS ---

    #[tokio::test]
    async fn test_wait_for_confirmation_immediate_success() {
        let provider = ConfigurableMockProvider::with_responses(vec![Ok(serde_json::json!({
            "value": [{
                "err": null,
                "confirmationStatus": "finalized"
            }]
        }))]);
        let config = RpcClientConfig::default();
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.wait_for_confirmation("test_sig", 5).await;
        assert!(result.is_ok());
        assert!(result.unwrap());
    }

    #[tokio::test]
    async fn test_wait_for_confirmation_eventual_success() {
        // First call: not confirmed, second call: confirmed
        let provider = ConfigurableMockProvider::with_responses(vec![
            Ok(serde_json::json!({"value": [null]})),
            Ok(serde_json::json!({
                "value": [{
                    "err": null,
                    "confirmationStatus": "confirmed"
                }]
            })),
        ]);
        let config = RpcClientConfig::default();
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        tokio::time::pause();
        let result = client.wait_for_confirmation("test_sig", 10).await;
        assert!(result.is_ok());
        assert!(result.unwrap());
    }

    #[tokio::test]
    async fn test_wait_for_confirmation_timeout() {
        // Always return not confirmed
        let provider = ConfigurableMockProvider::with_responses(vec![
            Ok(serde_json::json!({"value": [null]})),
            Ok(serde_json::json!({"value": [null]})),
            Ok(serde_json::json!({"value": [null]})),
            Ok(serde_json::json!({"value": [null]})),
            Ok(serde_json::json!({"value": [null]})),
        ]);
        let config = RpcClientConfig::default();
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        tokio::time::pause();
        let result = client.wait_for_confirmation("never_confirmed", 1).await;
        assert!(matches!(
            result,
            Err(AppError::Blockchain(BlockchainError::Timeout(_)))
        ));
    }

    #[tokio::test]
    async fn test_wait_for_confirmation_transaction_failed() {
        let provider = ConfigurableMockProvider::with_responses(vec![Ok(serde_json::json!({
            "value": [{
                "err": {"InstructionError": [0, "ProgramFailed"]},
                "confirmationStatus": "confirmed"
            }]
        }))]);
        let config = RpcClientConfig::default();
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.wait_for_confirmation("failed_tx", 5).await;
        assert!(matches!(
            result,
            Err(AppError::Blockchain(BlockchainError::TransactionFailed(_)))
        ));
    }

    // --- SUBMIT TRANSACTION TESTS (MOCK MODE) ---

    #[tokio::test]
    #[cfg(not(feature = "real-blockchain"))]
    async fn test_submit_transaction_mock_mode() {
        let provider = ConfigurableMockProvider::new();
        let config = RpcClientConfig::default();
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        // In mock mode (no real-blockchain feature), submit_transaction just signs
        let request = TransferRequest {
            id: "test_hash_123".to_string(),
            ..Default::default()
        };
        let result = client.submit_transaction(&request).await;
        assert!(result.is_ok());
        let signature = result.unwrap();
        assert!(signature.starts_with("tx_")); // Mock format
    }

    // --- RETRY LOGIC WITH CALL TRACKING ---

    #[tokio::test]
    async fn test_retry_counts_attempts_correctly() {
        let provider = ConfigurableMockProvider::with_responses(vec![
            Err(MockErrorKind::Timeout("fail 1".to_string())),
            Err(MockErrorKind::Timeout("fail 2".to_string())),
            Err(MockErrorKind::Timeout("fail 3".to_string())),
            Ok(serde_json::json!(999u64)), // Success on 4th attempt
        ]);
        let config = RpcClientConfig {
            max_retries: 3, // Initial + 3 retries = 4 attempts
            retry_delay: Duration::from_millis(1),
            ..Default::default()
        };
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.health_check().await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_no_retry_on_insufficient_funds() {
        // InsufficientFunds should still trigger retries as per current implementation
        let provider = ConfigurableMockProvider::with_responses(vec![
            Err(MockErrorKind::InsufficientFunds),
            Err(MockErrorKind::InsufficientFunds),
        ]);
        let config = RpcClientConfig {
            max_retries: 1,
            retry_delay: Duration::from_millis(1),
            ..Default::default()
        };
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        let result = client.health_check().await;
        assert!(matches!(
            result,
            Err(AppError::Blockchain(BlockchainError::InsufficientFunds))
        ));
        // Note: We can't check the provider's state after moving it into Box
        // The test validates that InsufficientFunds is eventually returned after retries
    }

    // --- WITH_PROVIDER CONSTRUCTOR TEST ---

    #[test]
    fn test_with_provider_constructor() {
        let provider = ConfigurableMockProvider::new();
        let config = RpcClientConfig {
            max_retries: 5,
            timeout: Duration::from_secs(45),
            ..Default::default()
        };
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        // Verify public key is accessible
        let pubkey = client.public_key();
        assert!(!pubkey.is_empty());

        // Verify signing works
        let sig = client.sign(b"test");
        assert!(!sig.is_empty());
    }

    // --- HTTP PROVIDER TESTS ---

    #[test]
    fn test_http_solana_rpc_provider_creation() {
        let signing_key = SigningKey::generate(&mut OsRng);
        let result = HttpSolanaRpcProvider::new(
            "https://api.devnet.solana.com",
            signing_key,
            Duration::from_secs(30),
        );
        assert!(result.is_ok());
    }

    #[test]
    fn test_http_solana_rpc_provider_public_key() {
        let signing_key = SigningKey::generate(&mut OsRng);
        let provider = HttpSolanaRpcProvider::new(
            "https://api.devnet.solana.com",
            signing_key.clone(),
            Duration::from_secs(30),
        )
        .unwrap();

        let pubkey = provider.public_key();
        assert!(!pubkey.is_empty());
        // Verify it matches the expected public key
        let expected = bs58::encode(signing_key.verifying_key().as_bytes()).into_string();
        assert_eq!(pubkey, expected);
    }

    #[test]
    fn test_http_solana_rpc_provider_sign() {
        let signing_key = SigningKey::generate(&mut OsRng);
        let provider = HttpSolanaRpcProvider::new(
            "https://api.devnet.solana.com",
            signing_key,
            Duration::from_secs(30),
        )
        .unwrap();

        let signature = provider.sign(b"test message");
        assert!(!signature.is_empty());
        // Signature should be base58 encoded
        let decoded = bs58::decode(&signature).into_vec();
        assert!(decoded.is_ok());
        assert_eq!(decoded.unwrap().len(), 64); // Ed25519 signature is 64 bytes
    }

    // --- JSON-RPC STRUCTURE TESTS ---

    #[test]
    fn test_json_rpc_response_with_result() {
        let json = serde_json::json!({
            "result": 12345,
            "error": null
        });
        let response: JsonRpcResponse<u64> = serde_json::from_value(json).unwrap();
        assert_eq!(response.result, Some(12345));
        assert!(response.error.is_none());
    }

    #[test]
    fn test_json_rpc_response_with_error() {
        let json = serde_json::json!({
            "result": null,
            "error": {
                "code": -32600,
                "message": "Invalid Request"
            }
        });
        let response: JsonRpcResponse<u64> = serde_json::from_value(json).unwrap();
        assert!(response.result.is_none());
        assert!(response.error.is_some());
        let error = response.error.unwrap();
        assert_eq!(error.code, -32600);
        assert_eq!(error.message, "Invalid Request");
    }

    #[test]
    fn test_json_rpc_error_insufficient_funds_by_message() {
        let json = serde_json::json!({
            "result": null,
            "error": {
                "code": -32000,
                "message": "Transaction simulation failed: insufficient lamports"
            }
        });
        let response: JsonRpcResponse<String> = serde_json::from_value(json).unwrap();
        let error = response.error.unwrap();
        // The message contains "insufficient" which triggers InsufficientFunds error
        assert!(error.message.contains("insufficient"));
    }

    #[test]
    fn test_json_rpc_error_insufficient_funds_by_code() {
        let json = serde_json::json!({
            "result": null,
            "error": {
                "code": -32002,
                "message": "Some other error"
            }
        });
        let response: JsonRpcResponse<String> = serde_json::from_value(json).unwrap();
        let error = response.error.unwrap();
        // Error code -32002 triggers InsufficientFunds
        assert_eq!(error.code, -32002);
    }

    // --- DESERIALIZATION ERROR TESTS ---

    #[tokio::test]
    async fn test_rpc_call_deserialization_error() {
        // Return a value that can't be deserialized to expected type
        let provider = ConfigurableMockProvider::with_responses(vec![
            Ok(serde_json::json!("not_a_number")), // String instead of u64
        ]);
        let config = RpcClientConfig {
            max_retries: 0,
            ..Default::default()
        };
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        // get_block_height expects u64, but we return a string
        let result = client.get_block_height().await;
        match result {
            Err(AppError::Blockchain(BlockchainError::RpcError(msg))) => {
                assert!(msg.contains("Deserialization error"));
            }
            _ => panic!("Expected deserialization error, got {:?}", result),
        }
    }

    #[tokio::test]
    async fn test_rpc_call_empty_response_after_retries() {
        // No responses configured - should use fallback null
        let provider = ConfigurableMockProvider::new();
        let config = RpcClientConfig {
            max_retries: 0,
            ..Default::default()
        };
        let client = RpcBlockchainClient::with_provider(Box::new(provider), config);

        // Try to get block height - provider returns null which can't deserialize to u64
        let result = client.get_block_height().await;
        assert!(result.is_err());
    }

    // --- SIGNING KEY ADDITIONAL TESTS ---

    #[test]
    fn test_signing_key_from_base58_64_bytes_invalid_keypair() {
        // Create 64 random bytes (not a valid keypair where bytes 32-64 are the public key)
        let invalid_keypair = vec![42u8; 64];
        let encoded = bs58::encode(&invalid_keypair).into_string();
        let secret = SecretString::from(encoded);

        // This should still work since we only use the first 32 bytes
        let result = signing_key_from_base58(&secret);
        assert!(result.is_ok());
    }

    #[test]
    fn test_signing_key_from_base58_empty_string() {
        let secret = SecretString::from("");
        let result = signing_key_from_base58(&secret);
        assert!(result.is_err());
    }

    // --- SDK-BASED TRANSFER TESTS (only with real-blockchain feature) ---

    #[cfg(feature = "real-blockchain")]
    mod real_blockchain_tests {
        use super::*;

        #[tokio::test]
        async fn test_submit_transaction_real_blockchain_path() {
            // This test verifies the SDK client is properly initialized
            // Actual transfer tests require network/mocking
            let signing_key = SigningKey::generate(&mut OsRng);
            let client =
                RpcBlockchainClient::with_defaults("https://api.devnet.solana.com", signing_key)
                    .unwrap();

            // Verify SDK components are initialized
            assert!(client.sdk_client.is_some());
            assert!(client.keypair.is_some());
            let _ = client.public_key();
        }
    }

    // --- RPC CLIENT NEW CONSTRUCTOR TEST ---

    #[test]
    fn test_rpc_blockchain_client_new() {
        let signing_key = SigningKey::generate(&mut OsRng);
        let config = RpcClientConfig {
            timeout: Duration::from_secs(15),
            max_retries: 2,
            retry_delay: Duration::from_millis(250),
            confirmation_timeout: Duration::from_secs(30),
        };
        let result = RpcBlockchainClient::new("https://api.devnet.solana.com", signing_key, config);
        assert!(result.is_ok());
    }

    // --- PROVIDER TRAIT OBJECT TESTS ---

    #[test]
    fn test_provider_as_trait_object() {
        let provider: Box<dyn SolanaRpcProvider> = Box::new(ConfigurableMockProvider::new());

        // Test public_key through trait object
        let pubkey = provider.public_key();
        assert!(!pubkey.is_empty());

        // Test sign through trait object
        let sig = provider.sign(b"message");
        assert!(!sig.is_empty());
    }

    // --- BLOCKHASH RESPONSE DESERIALIZATION ---

    #[test]
    fn test_blockhash_response_deserialization() {
        let json = serde_json::json!({
            "blockhash": "4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZAMdL4VZHirAn"
        });
        let response: BlockhashResponse = serde_json::from_value(json).unwrap();
        assert_eq!(
            response.blockhash,
            "4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZAMdL4VZHirAn"
        );
    }

    // --- ADDITIONAL RPC CLIENT CONFIG TESTS ---

    #[test]
    fn test_rpc_client_config_very_short_timeout() {
        let config = RpcClientConfig {
            timeout: Duration::from_millis(1),
            max_retries: 0,
            retry_delay: Duration::from_millis(1),
            confirmation_timeout: Duration::from_millis(1),
        };
        assert_eq!(config.timeout, Duration::from_millis(1));
    }

    #[test]
    fn test_rpc_client_config_zero_retries() {
        let config = RpcClientConfig {
            max_retries: 0,
            ..Default::default()
        };
        assert_eq!(config.max_retries, 0);
    }
}

===== ./infra/blockchain/strategies.rs =====
//! Provider Strategy Pattern for blockchain RPC providers.
//!
//! This module implements the Strategy Pattern to abstract blockchain provider
//! differences (Helius, QuickNode, Standard RPC) behind unified traits.
//! The system auto-detects the provider type and activates premium features accordingly.

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use tracing::{debug, info};

use crate::domain::AppError;

// ============================================================================
// PROVIDER TYPE DETECTION
// ============================================================================

/// Enum representing detected RPC provider type
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RpcProviderType {
    /// Helius RPC - Premium features available (Priority Fees, DAS)
    Helius,
    /// QuickNode RPC - Priority fee estimation available
    QuickNode,
    /// Standard Solana RPC - Basic functionality only
    Standard,
}

impl RpcProviderType {
    /// Detect provider type from RPC URL
    ///
    /// # Examples
    /// ```
    /// use solana_compliance_relayer::infra::blockchain::strategies::RpcProviderType;
    ///
    /// assert_eq!(
    ///     RpcProviderType::detect("https://mainnet.helius-rpc.com/?api-key=xxx"),
    ///     RpcProviderType::Helius
    /// );
    /// ```
    pub fn detect(rpc_url: &str) -> Self {
        let url_lower = rpc_url.to_lowercase();

        if url_lower.contains("helius-rpc.com") || url_lower.contains("helius.xyz") {
            RpcProviderType::Helius
        } else if url_lower.contains("quiknode.pro") || url_lower.contains("quicknode.com") {
            RpcProviderType::QuickNode
        } else {
            RpcProviderType::Standard
        }
    }

    /// Check if this provider supports Helius DAS API
    pub fn supports_das(&self) -> bool {
        matches!(self, RpcProviderType::Helius)
    }

    /// Get a human-readable name for logging
    pub fn name(&self) -> &'static str {
        match self {
            RpcProviderType::Helius => "Helius",
            RpcProviderType::QuickNode => "QuickNode",
            RpcProviderType::Standard => "Standard RPC",
        }
    }
}

// ============================================================================
// FEE STRATEGY TRAIT
// ============================================================================

/// Strategy for estimating priority fees
///
/// Different RPC providers have different APIs for fee estimation:
/// - Helius: `getPriorityFeeEstimate` with transaction-aware estimation
/// - QuickNode: `qn_estimatePriorityFees` with global estimation
/// - Standard: Static fallback value
#[async_trait]
pub trait FeeStrategy: Send + Sync {
    /// Get recommended priority fee in micro-lamports
    ///
    /// # Arguments
    /// * `serialized_tx` - Optional Base58-encoded serialized transaction
    ///                     (used by Helius for per-account fee estimation)
    async fn get_priority_fee(&self, serialized_tx: Option<&str>) -> u64;

    /// Human-readable strategy name for logging
    fn name(&self) -> &'static str;
}

// ============================================================================
// SUBMISSION STRATEGY TRAIT
// ============================================================================

/// Strategy for submitting transactions
///
/// Different providers offer different submission methods:
/// - Standard: `sendTransaction` RPC
/// - Helius: Smart Transactions with optimistic confirmation
/// - QuickNode: Ghost Mode via Jito bundles (private submission)
#[async_trait]
pub trait SubmissionStrategy: Send + Sync {
    /// Submit a serialized transaction
    ///
    /// # Arguments
    /// * `serialized_tx` - Base58-encoded serialized transaction
    /// * `skip_preflight` - Whether to skip preflight simulation
    ///
    /// # Returns
    /// Transaction signature on success
    async fn submit_transaction(
        &self,
        serialized_tx: &str,
        skip_preflight: bool,
    ) -> Result<String, AppError>;

    /// Human-readable strategy name for logging
    fn name(&self) -> &'static str;

    /// Returns true if this strategy supports private/MEV-protected submission
    ///
    /// Private submission bypasses the public mempool for enhanced privacy.
    /// Currently only available with QuickNode's Jito integration.
    fn supports_private_submission(&self) -> bool {
        false // Default: standard submission
    }
}

// ============================================================================
// FALLBACK FEE STRATEGY
// ============================================================================

/// Fallback fee strategy that returns a static default value
///
/// Used when no provider-specific fee estimation is available
pub struct FallbackFeeStrategy {
    default_fee: u64,
}

impl FallbackFeeStrategy {
    /// Create a new fallback strategy with the default fee (100 micro-lamports)
    pub fn new() -> Self {
        Self { default_fee: 100 }
    }

    /// Create a new fallback strategy with a custom default fee
    pub fn with_fee(fee: u64) -> Self {
        Self { default_fee: fee }
    }
}

impl Default for FallbackFeeStrategy {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl FeeStrategy for FallbackFeeStrategy {
    async fn get_priority_fee(&self, _serialized_tx: Option<&str>) -> u64 {
        debug!(
            fee = self.default_fee,
            "Using fallback priority fee (micro-lamports)"
        );
        self.default_fee
    }

    fn name(&self) -> &'static str {
        "Fallback (static)"
    }
}

// ============================================================================
// QUICKNODE FEE STRATEGY
// ============================================================================

/// Response structure for QuickNode's qn_estimatePriorityFees API
#[derive(Debug, Deserialize)]
pub struct QuickNodePriorityFeeResponse {
    pub per_compute_unit: Option<QuickNodePriorityFeeLevel>,
}

/// Priority fee levels from QuickNode API (values in micro-lamports)
#[derive(Debug, Deserialize)]
pub struct QuickNodePriorityFeeLevel {
    pub high: Option<f64>,
    #[allow(dead_code)]
    pub medium: Option<f64>,
    #[allow(dead_code)]
    pub low: Option<f64>,
}

/// QuickNode-specific fee strategy using `qn_estimatePriorityFees`
pub struct QuickNodeFeeStrategy {
    rpc_url: String,
    http_client: reqwest::Client,
    default_fee: u64,
}

impl QuickNodeFeeStrategy {
    pub fn new(rpc_url: &str) -> Self {
        Self {
            rpc_url: rpc_url.to_string(),
            http_client: reqwest::Client::new(),
            default_fee: 100,
        }
    }
}

#[derive(Debug, Serialize)]
struct JsonRpcRequest<T: Serialize> {
    jsonrpc: &'static str,
    id: u64,
    method: String,
    params: T,
}

#[derive(Debug, Deserialize)]
struct JsonRpcResponse<T> {
    result: Option<T>,
    #[allow(dead_code)]
    error: Option<serde_json::Value>,
}

#[async_trait]
impl FeeStrategy for QuickNodeFeeStrategy {
    async fn get_priority_fee(&self, _serialized_tx: Option<&str>) -> u64 {
        let params = serde_json::json!({
            "last_n_blocks": 100,
            "api_version": 2
        });

        let request = JsonRpcRequest {
            jsonrpc: "2.0",
            id: 1,
            method: "qn_estimatePriorityFees".to_string(),
            params,
        };

        match self
            .http_client
            .post(&self.rpc_url)
            .json(&request)
            .send()
            .await
        {
            Ok(response) => {
                match response
                    .json::<JsonRpcResponse<QuickNodePriorityFeeResponse>>()
                    .await
                {
                    Ok(rpc_response) => {
                        if let Some(result) = rpc_response.result {
                            if let Some(fees) = result.per_compute_unit {
                                if let Some(high) = fees.high {
                                    let fee = high as u64;
                                    info!(
                                        priority_fee = %fee,
                                        "⚡ QuickNode priority fee applied (micro-lamports)"
                                    );
                                    return fee;
                                }
                            }
                        }
                        debug!("QuickNode response missing fee data, using default");
                        self.default_fee
                    }
                    Err(e) => {
                        debug!(error = %e, "Failed to parse QuickNode response, using default");
                        self.default_fee
                    }
                }
            }
            Err(e) => {
                debug!(error = %e, "QuickNode API request failed, using default");
                self.default_fee
            }
        }
    }

    fn name(&self) -> &'static str {
        "QuickNode (qn_estimatePriorityFees)"
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_provider_detection_helius() {
        assert_eq!(
            RpcProviderType::detect("https://mainnet.helius-rpc.com/?api-key=xxx"),
            RpcProviderType::Helius
        );
        assert_eq!(
            RpcProviderType::detect("https://devnet.helius-rpc.com"),
            RpcProviderType::Helius
        );
        assert_eq!(
            RpcProviderType::detect("https://rpc.helius.xyz/?api-key=test"),
            RpcProviderType::Helius
        );
    }

    #[test]
    fn test_provider_detection_quicknode() {
        assert_eq!(
            RpcProviderType::detect("https://xxx.solana-mainnet.quiknode.pro/yyy"),
            RpcProviderType::QuickNode
        );
        assert_eq!(
            RpcProviderType::detect("https://my-endpoint.quicknode.com"),
            RpcProviderType::QuickNode
        );
    }

    #[test]
    fn test_provider_detection_standard() {
        assert_eq!(
            RpcProviderType::detect("https://api.mainnet-beta.solana.com"),
            RpcProviderType::Standard
        );
        assert_eq!(
            RpcProviderType::detect("https://api.devnet.solana.com"),
            RpcProviderType::Standard
        );
        assert_eq!(
            RpcProviderType::detect("http://localhost:8899"),
            RpcProviderType::Standard
        );
    }

    #[test]
    fn test_provider_supports_das() {
        assert!(RpcProviderType::Helius.supports_das());
        assert!(!RpcProviderType::QuickNode.supports_das());
        assert!(!RpcProviderType::Standard.supports_das());
    }

    #[tokio::test]
    async fn test_fallback_fee_strategy() {
        let strategy = FallbackFeeStrategy::new();
        assert_eq!(strategy.get_priority_fee(None).await, 100);
        assert_eq!(strategy.name(), "Fallback (static)");
    }

    #[tokio::test]
    async fn test_fallback_fee_strategy_custom() {
        let strategy = FallbackFeeStrategy::with_fee(500);
        assert_eq!(strategy.get_priority_fee(None).await, 500);
    }
}

===== ./infra/compliance/mod.rs =====
pub mod range;

pub use range::RangeComplianceProvider;

===== ./infra/compliance/range.rs =====
//! Range compliance provider implementation.
//!
//! This module provides integration with Range Protocol's Risk API
//! for wallet address screening and compliance checks.

use async_trait::async_trait;
use reqwest::Client;
use serde::Deserialize;
use tracing::{debug, error, info, instrument, warn};

use crate::domain::{AppError, ComplianceProvider, ComplianceStatus, SubmitTransferRequest};

/// Default Range Protocol API base URL
pub const DEFAULT_RANGE_API_URL: &str = "https://api.range.org/v1";

/// Detailed malicious address info
#[derive(Debug, Deserialize, Clone)]
pub struct MaliciousAddress {
    pub address: String,
    pub distance: u32,
    #[serde(default)]
    pub name_tag: String,
    pub entity: Option<String>,
    #[serde(default)]
    pub category: String,
    #[serde(default)]
    pub risk_categories: Vec<String>,
}

/// Attribution info
#[derive(Debug, Deserialize, Clone)]
pub struct Attribution {
    #[serde(default)]
    pub name_tag: String,
    pub entity: Option<String>,
    #[serde(default)]
    pub category: String,
    #[serde(default)]
    pub address_role: String,
    #[serde(default)]
    pub risk_categories: Vec<String>,
}

/// Response from Range Protocol Risk API
///
/// Example Response:
/// {
///   "riskScore": 1,
///   "riskLevel": "Very low risk",
///   "numHops": 2,
///   "maliciousAddressesFound": [],
///   "reasoning": "...",
///   "attribution": { ... }
/// }
#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RiskResponse {
    pub risk_score: i32,
    pub risk_level: String,
    pub num_hops: Option<u32>,
    #[serde(default)]
    pub malicious_addresses_found: Vec<MaliciousAddress>,
    #[serde(default)]
    pub reasoning: String,
    pub attribution: Option<Attribution>,
}

/// Compliance provider that screens addresses via Range Protocol API
#[derive(Debug, Clone)]
pub struct RangeComplianceProvider {
    http_client: Client,
    api_key: Option<String>,
    base_url: String,
}

impl Default for RangeComplianceProvider {
    fn default() -> Self {
        Self::new(None, None)
    }
}

impl RangeComplianceProvider {
    /// Create a new Range compliance provider
    ///
    /// # Arguments
    /// * `api_key` - Optional API key for Range Protocol. If None, uses mock mode.
    /// * `base_url` - Optional custom API base URL. Defaults to Range Protocol production.
    pub fn new(api_key: Option<String>, base_url: Option<String>) -> Self {
        let http_client = Client::builder()
            .timeout(std::time::Duration::from_secs(30))
            .build()
            .expect("Failed to create HTTP client");

        Self {
            http_client,
            api_key,
            base_url: base_url.unwrap_or_else(|| DEFAULT_RANGE_API_URL.to_string()),
        }
    }

    /// Check if running in mock mode (no API key configured)
    fn is_mock_mode(&self) -> bool {
        self.api_key.is_none()
    }

    /// Perform mock compliance check (for development/testing)
    fn mock_check(&self, to_address: &str) -> ComplianceStatus {
        // Block strict match for known test addresses
        if to_address == "hack_the_planet_bad_wallet" {
            return ComplianceStatus::Rejected;
        }

        // Block pattern match for addresses starting with "hack"
        if to_address.to_lowercase().starts_with("hack") {
            return ComplianceStatus::Rejected;
        }

        ComplianceStatus::Approved
    }

    /// Call Range Protocol Risk API
    async fn check_address_risk(&self, address: &str) -> Result<RiskResponse, AppError> {
        let api_key = self.api_key.as_ref().ok_or_else(|| {
            AppError::ExternalService(crate::domain::ExternalServiceError::Configuration(
                "RANGE_API_KEY not configured".to_string(),
            ))
        })?;

        let url = format!("{}/risk/address", self.base_url);

        debug!(url = %url, address = %address, "Calling Range Protocol Risk API");

        let response = self
            .http_client
            .get(&url)
            .header("Authorization", format!("Bearer {}", api_key))
            .header("Content-Type", "application/json")
            .query(&[("address", address), ("network", "solana")])
            .send()
            .await
            .map_err(|e| {
                error!(error = %e, "Range Protocol API request failed");
                AppError::ExternalService(crate::domain::ExternalServiceError::Network(
                    e.to_string(),
                ))
            })?;

        if !response.status().is_success() {
            let status = response.status();
            let body = response.text().await.unwrap_or_default();
            error!(status = %status, body = %body, "Range Protocol API returned error");
            return Err(AppError::ExternalService(
                crate::domain::ExternalServiceError::ApiError {
                    status_code: status.as_u16(),
                    message: body,
                },
            ));
        }

        // Get raw body text first for debugging if parsing fails
        let body_text = response.text().await.map_err(|e| {
            error!(error = %e, "Failed to read Range Protocol response body");
            AppError::ExternalService(crate::domain::ExternalServiceError::Network(e.to_string()))
        })?;

        let risk_response: RiskResponse = serde_json::from_str(&body_text).map_err(|e| {
            error!(
                error = %e,
                raw_body = %body_text,
                "Failed to parse Range Protocol response - logging raw body for debugging"
            );
            AppError::ExternalService(crate::domain::ExternalServiceError::ParseError(format!(
                "JSON parse error: {}. Raw body: {}",
                e, body_text
            )))
        })?;

        debug!(
            score = %risk_response.risk_score,
            level = %risk_response.risk_level,
            "Range Protocol risk check complete"
        );

        Ok(risk_response)
    }

    /// Determine compliance status from risk response
    ///
    /// Rule: If riskScore >= 70 OR riskLevel contains "High" or "Severe",
    /// return ComplianceStatus::Rejected. Otherwise, return ComplianceStatus::Approved.
    fn evaluate_risk(&self, response: &RiskResponse) -> ComplianceStatus {
        // High risk logic: Score >= 70 or risk level description indicating high/severe risk
        let is_high_risk = response.risk_score >= 70
            || response.risk_level.contains("High")
            || response.risk_level.contains("Severe");

        if is_high_risk {
            info!(
                risk_score = %response.risk_score,
                risk_level = %response.risk_level,
                "Address rejected: high risk detected"
            );
            ComplianceStatus::Rejected
        } else {
            debug!(
                risk_score = %response.risk_score,
                risk_level = %response.risk_level,
                "Address approved"
            );
            ComplianceStatus::Approved
        }
    }
}

#[async_trait]
impl ComplianceProvider for RangeComplianceProvider {
    #[instrument(skip(self, request), fields(from = %request.from_address, to = %request.to_address))]
    async fn check_compliance(
        &self,
        request: &SubmitTransferRequest,
    ) -> Result<ComplianceStatus, AppError> {
        // Use mock mode if no API key is configured
        if self.is_mock_mode() {
            warn!("Running in mock compliance mode - no RANGE_API_KEY configured");
            return Ok(self.mock_check(&request.to_address));
        }

        // Check destination address against Range Protocol
        match self.check_address_risk(&request.to_address).await {
            Ok(response) => Ok(self.evaluate_risk(&response)),
            Err(e) => {
                // On API error, default to rejection for safety
                error!(
                    error = ?e,
                    to_address = %request.to_address,
                    "Range Protocol API error - defaulting to rejection for safety"
                );
                Ok(ComplianceStatus::Rejected)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::TransferType;

    #[test]
    fn test_mock_mode_approved() {
        let provider = RangeComplianceProvider::new(None, None);
        assert!(provider.is_mock_mode());

        let status = provider.mock_check("HvwC9QSAzwEXkUkwqNNGhfNHoVqXJYfPvPZfQvJmHWcF");
        assert_eq!(status, ComplianceStatus::Approved);
    }

    #[test]
    fn test_mock_mode_rejected_exact_match() {
        let provider = RangeComplianceProvider::new(None, None);
        let status = provider.mock_check("hack_the_planet_bad_wallet");
        assert_eq!(status, ComplianceStatus::Rejected);
    }

    #[test]
    fn test_mock_mode_rejected_prefix() {
        let provider = RangeComplianceProvider::new(None, None);
        let status = provider.mock_check("hackSomeAddress123");
        assert_eq!(status, ComplianceStatus::Rejected);
    }

    #[test]
    fn test_risk_evaluation_high_score() {
        let provider = RangeComplianceProvider::new(Some("test_key".to_string()), None);
        let response = RiskResponse {
            risk_score: 70, // Exactly at threshold
            risk_level: "High risk".to_string(),
            num_hops: Some(1),
            malicious_addresses_found: vec![],
            reasoning: "Bad actor".to_string(),
            attribution: None,
        };
        assert_eq!(
            provider.evaluate_risk(&response),
            ComplianceStatus::Rejected
        );
    }

    #[test]
    fn test_risk_evaluation_score_just_below_threshold() {
        let provider = RangeComplianceProvider::new(Some("test_key".to_string()), None);
        let response = RiskResponse {
            risk_score: 69, // Just below threshold
            risk_level: "Medium risk".to_string(),
            num_hops: Some(1),
            malicious_addresses_found: vec![],
            reasoning: "Borderline case".to_string(),
            attribution: None,
        };
        assert_eq!(
            provider.evaluate_risk(&response),
            ComplianceStatus::Approved
        );
    }

    #[test]
    fn test_risk_evaluation_low_score_but_high_risk_text() {
        let provider = RangeComplianceProvider::new(Some("test_key".to_string()), None);
        let response = RiskResponse {
            risk_score: 10, // Low score but text says High (edge case safety)
            risk_level: "High risk".to_string(),
            num_hops: Some(1),
            malicious_addresses_found: vec![],
            reasoning: "Manual override".to_string(),
            attribution: None,
        };
        assert_eq!(
            provider.evaluate_risk(&response),
            ComplianceStatus::Rejected
        );
    }

    #[test]
    fn test_risk_evaluation_low_risk_approved() {
        let provider = RangeComplianceProvider::new(Some("test_key".to_string()), None);
        let response = RiskResponse {
            risk_score: 1,
            risk_level: "Very low risk".to_string(),
            num_hops: Some(2),
            malicious_addresses_found: vec![],
            reasoning: "Safe".to_string(),
            attribution: None,
        };
        assert_eq!(
            provider.evaluate_risk(&response),
            ComplianceStatus::Approved
        );
    }

    #[tokio::test]
    async fn test_check_compliance_mock_mode() {
        let provider = RangeComplianceProvider::new(None, None);
        let request = SubmitTransferRequest {
            from_address: "sender".to_string(),
            to_address: "receiver".to_string(),
            transfer_details: TransferType::Public {
                amount: 1_000_000_000,
            },
            token_mint: None,
            signature: "dummy_sig".to_string(),
        };
        let result = provider.check_compliance(&request).await;
        assert_eq!(result.unwrap(), ComplianceStatus::Approved);
    }

    #[tokio::test]
    async fn test_check_compliance_mock_mode_rejected() {
        let provider = RangeComplianceProvider::new(None, None);
        let request = SubmitTransferRequest {
            from_address: "sender".to_string(),
            to_address: "hackBadWallet".to_string(),
            transfer_details: TransferType::Public {
                amount: 1_000_000_000,
            },
            token_mint: None,
            signature: "dummy_sig".to_string(),
        };
        let result = provider.check_compliance(&request).await;
        assert_eq!(result.unwrap(), ComplianceStatus::Rejected);
    }
}

===== ./infra/database/mod.rs =====
//! Database client implementations.

pub mod postgres;

pub use postgres::{PostgresClient, PostgresConfig};

===== ./infra/database/postgres.rs =====
//! PostgreSQL database client implementation.

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use sqlx::{PgPool, Row, postgres::PgPoolOptions};
use std::time::Duration;
use tracing::{info, instrument};

use crate::domain::types::TransferType;
use crate::domain::{
    AppError, BlockchainStatus, ComplianceStatus, DatabaseClient, DatabaseError, PaginatedResponse,
    SubmitTransferRequest, TransferRequest,
};

/// PostgreSQL connection pool configuration
#[derive(Debug, Clone)]
pub struct PostgresConfig {
    pub max_connections: u32,
    pub min_connections: u32,
    pub acquire_timeout: Duration,
    pub idle_timeout: Duration,
    pub max_lifetime: Duration,
}

impl Default for PostgresConfig {
    fn default() -> Self {
        Self {
            max_connections: 10,
            min_connections: 2,
            acquire_timeout: Duration::from_secs(3),
            idle_timeout: Duration::from_secs(600),
            max_lifetime: Duration::from_secs(1800),
        }
    }
}

/// PostgreSQL database client with connection pooling
pub struct PostgresClient {
    pool: PgPool,
}

impl PostgresClient {
    /// Create a new PostgreSQL client with custom configuration
    pub async fn new(database_url: &str, config: PostgresConfig) -> Result<Self, AppError> {
        info!("Connecting to PostgreSQL...");
        let pool = PgPoolOptions::new()
            .max_connections(config.max_connections)
            .min_connections(config.min_connections)
            .acquire_timeout(config.acquire_timeout)
            .idle_timeout(config.idle_timeout)
            .max_lifetime(config.max_lifetime)
            .connect(database_url)
            .await
            .map_err(|e| AppError::Database(DatabaseError::Connection(e.to_string())))?;
        info!("Connected to PostgreSQL");
        Ok(Self { pool })
    }

    /// Create a new PostgreSQL client with default configuration
    pub async fn with_defaults(database_url: &str) -> Result<Self, AppError> {
        Self::new(database_url, PostgresConfig::default()).await
    }

    /// Run database migrations using sqlx migrate
    pub async fn run_migrations(&self) -> Result<(), AppError> {
        info!("Running database migrations...");
        sqlx::migrate!("./migrations")
            .run(&self.pool)
            .await
            .map_err(|e| AppError::Database(DatabaseError::Migration(e.to_string())))?;
        info!("Database migrations completed successfully");
        Ok(())
    }

    /// Get the underlying connection pool (for testing)
    #[must_use]
    pub fn pool(&self) -> &PgPool {
        &self.pool
    }

    /// Parse a database row into a TransferRequest
    fn row_to_transfer_request(row: &sqlx::postgres::PgRow) -> Result<TransferRequest, AppError> {
        let compliance_status_str: String = row.get("compliance_status");
        let blockchain_status_str: String = row.get("blockchain_status");

        // New fields for confidential transfers
        let transfer_type_str: Option<String> = row.try_get("transfer_type").ok();
        let amount_opt: Option<i64> = row.get("amount");
        let new_decryptable_available_balance: Option<String> =
            row.try_get("new_decryptable_available_balance").ok();
        let equality_proof: Option<String> = row.try_get("equality_proof").ok();
        let ciphertext_validity_proof: Option<String> =
            row.try_get("ciphertext_validity_proof").ok();
        let range_proof: Option<String> = row.try_get("range_proof").ok();

        let transfer_details = match transfer_type_str.as_deref() {
            Some("confidential") => TransferType::Confidential {
                new_decryptable_available_balance: new_decryptable_available_balance
                    .unwrap_or_default(),
                equality_proof: equality_proof.unwrap_or_default(),
                ciphertext_validity_proof: ciphertext_validity_proof.unwrap_or_default(),
                range_proof: range_proof.unwrap_or_default(),
            },
            // Default to Public if "public" or unknown/null (backward compatibility)
            _ => TransferType::Public {
                amount: amount_opt.unwrap_or(0) as u64,
            },
        };

        Ok(TransferRequest {
            id: row.get("id"),
            from_address: row.get("from_address"),
            to_address: row.get("to_address"),
            transfer_details,
            token_mint: row.get("token_mint"),
            compliance_status: compliance_status_str
                .parse()
                .unwrap_or(ComplianceStatus::Pending),
            blockchain_status: blockchain_status_str
                .parse()
                .unwrap_or(BlockchainStatus::Pending),
            blockchain_signature: row.get("blockchain_signature"),
            blockchain_retry_count: row.get("blockchain_retry_count"),
            blockchain_last_error: row.get("blockchain_last_error"),
            blockchain_next_retry_at: row.get("blockchain_next_retry_at"),
            created_at: row.get("created_at"),
            updated_at: row.get("updated_at"),
        })
    }
}

#[async_trait]
impl DatabaseClient for PostgresClient {
    #[instrument(skip(self))]
    async fn health_check(&self) -> Result<(), AppError> {
        sqlx::query("SELECT 1")
            .execute(&self.pool)
            .await
            .map_err(|e| AppError::Database(DatabaseError::Connection(e.to_string())))?;
        Ok(())
    }

    #[instrument(skip(self))]
    async fn get_transfer_request(&self, id: &str) -> Result<Option<TransferRequest>, AppError> {
        let row = sqlx::query(
            r#"
            SELECT id, from_address, to_address, amount, token_mint, compliance_status,
                   blockchain_status, blockchain_signature, blockchain_retry_count,
                   blockchain_last_error, blockchain_next_retry_at,
                   created_at, updated_at,
                   transfer_type, new_decryptable_available_balance, equality_proof, ciphertext_validity_proof, range_proof
            FROM transfer_requests 
            WHERE id = $1
            "#,
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| AppError::Database(DatabaseError::Query(e.to_string())))?;

        match row {
            Some(row) => Ok(Some(Self::row_to_transfer_request(&row)?)),
            None => Ok(None),
        }
    }

    #[instrument(skip(self, data), fields(from = %data.from_address, to = %data.to_address))]
    async fn submit_transfer(
        &self,
        data: &SubmitTransferRequest,
    ) -> Result<TransferRequest, AppError> {
        let id = uuid::Uuid::new_v4().to_string();
        let now = Utc::now();

        let (
            transfer_type_str,
            amount,
            new_decryptable_available_balance,
            equality_proof,
            ciphertext_validity_proof,
            range_proof,
        ) = match &data.transfer_details {
            TransferType::Public { amount } => {
                ("public", Some(*amount as i64), None, None, None, None)
            }
            TransferType::Confidential {
                new_decryptable_available_balance,
                equality_proof,
                ciphertext_validity_proof,
                range_proof,
            } => (
                "confidential",
                None,
                Some(new_decryptable_available_balance.clone()),
                Some(equality_proof.clone()),
                Some(ciphertext_validity_proof.clone()),
                Some(range_proof.clone()),
            ),
        };

        sqlx::query(
            r#"
            INSERT INTO transfer_requests (
                id, from_address, to_address, amount, token_mint,
                compliance_status, blockchain_status, blockchain_retry_count,
                created_at, updated_at,
                transfer_type, new_decryptable_available_balance, equality_proof, ciphertext_validity_proof, range_proof
            ) 
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
            "#,
        )
        .bind(&id)
        .bind(&data.from_address)
        .bind(&data.to_address)
        .bind(amount)
        .bind(data.token_mint.as_deref())
        .bind(ComplianceStatus::Pending.as_str())
        .bind(BlockchainStatus::Pending.as_str())
        .bind(0i32)
        .bind(now)
        .bind(now)
        .bind(transfer_type_str)
        .bind(new_decryptable_available_balance)
        .bind(equality_proof)
        .bind(ciphertext_validity_proof)
        .bind(range_proof)
        .execute(&self.pool)
        .await
        .map_err(|e| AppError::Database(DatabaseError::from(e)))?;

        Ok(TransferRequest {
            id,
            from_address: data.from_address.clone(),
            to_address: data.to_address.clone(),
            transfer_details: data.transfer_details.clone(),
            token_mint: data.token_mint.clone(),
            compliance_status: ComplianceStatus::Pending,
            blockchain_status: BlockchainStatus::Pending,
            blockchain_signature: None,
            blockchain_retry_count: 0,
            blockchain_last_error: None,
            blockchain_next_retry_at: None,
            created_at: now,
            updated_at: now,
        })
    }

    #[instrument(skip(self))]
    async fn list_transfer_requests(
        &self,
        limit: i64,
        cursor: Option<&str>,
    ) -> Result<PaginatedResponse<TransferRequest>, AppError> {
        // Clamp limit to valid range
        let limit = limit.clamp(1, 100);
        // Fetch one extra to determine if there are more items
        let fetch_limit = limit + 1;

        let rows = match cursor {
            Some(cursor_id) => {
                // Get the created_at of the cursor item for proper pagination
                let cursor_row =
                    sqlx::query("SELECT created_at FROM transfer_requests WHERE id = $1")
                        .bind(cursor_id)
                        .fetch_optional(&self.pool)
                        .await
                        .map_err(|e| AppError::Database(DatabaseError::Query(e.to_string())))?;

                let cursor_created_at: DateTime<Utc> = match cursor_row {
                    Some(row) => row.get("created_at"),
                    None => {
                        return Err(AppError::Validation(
                            crate::domain::ValidationError::InvalidField {
                                field: "cursor".to_string(),
                                message: "Invalid cursor".to_string(),
                            },
                        ));
                    }
                };

                sqlx::query(
                    r#"
                    SELECT id, from_address, to_address, amount, token_mint, compliance_status,
                           blockchain_status, blockchain_signature, blockchain_retry_count,
                           blockchain_last_error, blockchain_next_retry_at,
                           created_at, updated_at,
                           transfer_type, new_decryptable_available_balance, equality_proof, ciphertext_validity_proof, range_proof
                    FROM transfer_requests
                    WHERE (created_at, id) < ($1, $2)
                    ORDER BY created_at DESC, id DESC
                    LIMIT $3
                    "#,
                )
                .bind(cursor_created_at)
                .bind(cursor_id)
                .bind(fetch_limit)
                .fetch_all(&self.pool)
                .await
                .map_err(|e| AppError::Database(DatabaseError::Query(e.to_string())))?
            }
            None => sqlx::query(
                r#"
                    SELECT id, from_address, to_address, amount, token_mint, compliance_status,
                           blockchain_status, blockchain_signature, blockchain_retry_count,
                           blockchain_last_error, blockchain_next_retry_at,
                           created_at, updated_at,
                           transfer_type, new_decryptable_available_balance, equality_proof, ciphertext_validity_proof, range_proof
                    FROM transfer_requests
                    ORDER BY created_at DESC, id DESC
                    LIMIT $1
                    "#,
            )
            .bind(fetch_limit)
            .fetch_all(&self.pool)
            .await
            .map_err(|e| AppError::Database(DatabaseError::Query(e.to_string())))?,
        };

        let has_more = rows.len() > limit as usize;
        let requests: Vec<TransferRequest> = rows
            .iter()
            .take(limit as usize)
            .map(Self::row_to_transfer_request)
            .collect::<Result<Vec<_>, _>>()?;

        let next_cursor = if has_more {
            requests.last().map(|req| req.id.clone())
        } else {
            None
        };

        Ok(PaginatedResponse::new(requests, next_cursor, has_more))
    }

    #[instrument(skip(self))]
    async fn update_blockchain_status(
        &self,
        id: &str,
        status: BlockchainStatus,
        signature: Option<&str>,
        error: Option<&str>,
        next_retry_at: Option<DateTime<Utc>>,
    ) -> Result<(), AppError> {
        let now = Utc::now();

        sqlx::query(
            r#"
            UPDATE transfer_requests 
            SET blockchain_status = $1,
                blockchain_signature = COALESCE($2, blockchain_signature),
                blockchain_last_error = $3,
                blockchain_next_retry_at = $4,
                updated_at = $5
            WHERE id = $6
            "#,
        )
        .bind(status.as_str())
        .bind(signature)
        .bind(error)
        .bind(next_retry_at)
        .bind(now)
        .bind(id)
        .execute(&self.pool)
        .await
        .map_err(|e| AppError::Database(DatabaseError::Query(e.to_string())))?;

        Ok(())
    }

    #[instrument(skip(self))]
    async fn update_compliance_status(
        &self,
        id: &str,
        status: ComplianceStatus,
    ) -> Result<(), AppError> {
        let now = Utc::now();
        sqlx::query(
            r#"
            UPDATE transfer_requests 
            SET compliance_status = $1,
                updated_at = $2
            WHERE id = $3
            "#,
        )
        .bind(status.as_str())
        .bind(now)
        .bind(id)
        .execute(&self.pool)
        .await
        .map_err(|e| AppError::Database(DatabaseError::Query(e.to_string())))?;

        Ok(())
    }

    /// Get pending blockchain requests and atomically claim them for processing.
    /// Uses UPDATE...RETURNING with FOR UPDATE SKIP LOCKED to prevent race conditions.
    /// Returned rows are already in 'processing' status.
    #[instrument(skip(self))]
    async fn get_pending_blockchain_requests(
        &self,
        limit: i64,
    ) -> Result<Vec<TransferRequest>, AppError> {
        let now = Utc::now();
        // Atomic claim: SELECT eligible rows with FOR UPDATE SKIP LOCKED,
        // UPDATE them to 'processing', and RETURN them in one operation.
        // This prevents race conditions when multiple worker replicas are running.
        let rows = sqlx::query(
            r#"
            UPDATE transfer_requests
            SET blockchain_status = 'processing',
                updated_at = NOW()
            WHERE id IN (
                SELECT id FROM transfer_requests
                WHERE blockchain_status = 'pending_submission'
                  AND compliance_status = 'approved'
                  AND (blockchain_next_retry_at IS NULL OR blockchain_next_retry_at <= $1)
                  AND blockchain_retry_count < 10
                ORDER BY blockchain_next_retry_at ASC NULLS FIRST, created_at ASC
                LIMIT $2
                FOR UPDATE SKIP LOCKED
            )
            RETURNING id, from_address, to_address, amount, token_mint, compliance_status,
                      blockchain_status, blockchain_signature, blockchain_retry_count,
                      blockchain_last_error, blockchain_next_retry_at, created_at, updated_at,
                      transfer_type, new_decryptable_available_balance, equality_proof, ciphertext_validity_proof, range_proof
            "#,
        )
        .bind(now)
        .bind(limit)
        .fetch_all(&self.pool)
        .await
        .map_err(|e| AppError::Database(DatabaseError::Query(e.to_string())))?;

        rows.iter().map(Self::row_to_transfer_request).collect()
    }

    #[instrument(skip(self))]
    async fn increment_retry_count(&self, id: &str) -> Result<i32, AppError> {
        let row = sqlx::query(
            r#"
            UPDATE transfer_requests 
            SET blockchain_retry_count = blockchain_retry_count + 1,
                updated_at = NOW()
            WHERE id = $1
            RETURNING blockchain_retry_count
            "#,
        )
        .bind(id)
        .fetch_one(&self.pool)
        .await
        .map_err(|e| AppError::Database(DatabaseError::Query(e.to_string())))?;

        Ok(row.get("blockchain_retry_count"))
    }

    #[instrument(skip(self))]
    async fn get_transfer_by_signature(
        &self,
        signature: &str,
    ) -> Result<Option<TransferRequest>, AppError> {
        let row = sqlx::query(
            r#"
            SELECT id, from_address, to_address, amount, token_mint, compliance_status,
                   blockchain_status, blockchain_signature, blockchain_retry_count,
                   blockchain_last_error, blockchain_next_retry_at,
                   created_at, updated_at,
                   transfer_type, new_decryptable_available_balance, equality_proof, ciphertext_validity_proof, range_proof 
            FROM transfer_requests 
            WHERE blockchain_signature = $1
            "#,
        )
        .bind(signature)
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| AppError::Database(DatabaseError::Query(e.to_string())))?;

        match row {
            Some(row) => Ok(Some(Self::row_to_transfer_request(&row)?)),
            None => Ok(None),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_postgres_config_default() {
        let config = PostgresConfig::default();
        assert_eq!(config.max_connections, 10);
        assert_eq!(config.min_connections, 2);
        assert_eq!(config.acquire_timeout, Duration::from_secs(3));
        assert_eq!(config.idle_timeout, Duration::from_secs(600));
        assert_eq!(config.max_lifetime, Duration::from_secs(1800));
    }

    #[test]
    fn test_postgres_config_custom() {
        let config = PostgresConfig {
            max_connections: 20,
            min_connections: 5,
            acquire_timeout: Duration::from_secs(10),
            idle_timeout: Duration::from_secs(300),
            max_lifetime: Duration::from_secs(3600),
        };
        assert_eq!(config.max_connections, 20);
        assert_eq!(config.min_connections, 5);
        assert_eq!(config.acquire_timeout, Duration::from_secs(10));
        assert_eq!(config.idle_timeout, Duration::from_secs(300));
        assert_eq!(config.max_lifetime, Duration::from_secs(3600));
    }
}

===== ./infra/mod.rs =====
//! Infrastructure layer implementations.

pub mod blockchain;
pub mod compliance;
pub mod database;
pub mod privacy;

pub use blockchain::{RpcBlockchainClient, RpcClientConfig, signing_key_from_base58};
pub use compliance::RangeComplianceProvider;
pub use database::{PostgresClient, PostgresConfig};
pub use privacy::{AnonymitySetHealth, PrivacyHealthCheckConfig, PrivacyHealthCheckService};

===== ./infra/privacy/health_check.rs =====
//! Anonymity Set Health Check Service
//!
//! Assesses the recent transaction volume ("anonymity set health") for a
//! given confidential token mint before submission. Implements smart delays
//! when network activity is low to mitigate timing attacks.
//!
//! # How It Works
//! 1. Before submitting a confidential transfer, the worker queries this service
//! 2. The service fetches recent transaction activity for the token mint
//! 3. If activity is below the threshold, a randomized delay is recommended
//! 4. The transaction is postponed to blend with future network activity
//!
//! # Graceful Degradation
//! If the Token API is unavailable or returns an error, the check is skipped
//! and the transaction proceeds immediately (prioritizing liveness over privacy).

use chrono::{DateTime, Utc};
use rand::Rng;
use std::sync::Arc;
use tracing::{debug, info, warn};

use crate::infra::blockchain::quicknode::QuickNodeTokenApiClient;

// ============================================================================
// CONFIGURATION
// ============================================================================

/// Configuration for the Privacy Health Check service
#[derive(Debug, Clone)]
pub struct PrivacyHealthCheckConfig {
    /// Minimum number of recent transactions to consider "healthy"
    pub min_tx_threshold: u64,
    /// Lookback window in minutes for activity assessment
    pub lookback_minutes: u64,
    /// Maximum delay in seconds when activity is low
    pub max_delay_secs: u64,
    /// Minimum delay in seconds when activity is low
    pub min_delay_secs: u64,
    /// Whether the health check is enabled
    pub enabled: bool,
}

impl Default for PrivacyHealthCheckConfig {
    fn default() -> Self {
        Self {
            min_tx_threshold: 5,  // Require 5+ transactions
            lookback_minutes: 10, // In the last 10 minutes
            max_delay_secs: 120,  // Max 2 minute delay
            min_delay_secs: 10,   // Min 10 second delay
            enabled: true,
        }
    }
}

impl PrivacyHealthCheckConfig {
    /// Create a disabled configuration
    pub fn disabled() -> Self {
        Self {
            enabled: false,
            ..Default::default()
        }
    }

    /// Load configuration from environment variables
    pub fn from_env() -> Self {
        use std::env;

        let min_tx_threshold = env::var("PRIVACY_MIN_TX_THRESHOLD")
            .ok()
            .and_then(|v| v.parse().ok())
            .unwrap_or(5);

        let lookback_minutes = env::var("PRIVACY_LOOKBACK_MINUTES")
            .ok()
            .and_then(|v| v.parse().ok())
            .unwrap_or(10);

        let max_delay_secs = env::var("PRIVACY_MAX_DELAY_SECS")
            .ok()
            .and_then(|v| v.parse().ok())
            .unwrap_or(120);

        let min_delay_secs = env::var("PRIVACY_MIN_DELAY_SECS")
            .ok()
            .and_then(|v| v.parse().ok())
            .unwrap_or(10);

        let enabled = env::var("ENABLE_PRIVACY_CHECKS")
            .map(|v| v == "true" || v == "1")
            .unwrap_or(true);

        Self {
            min_tx_threshold,
            lookback_minutes,
            max_delay_secs,
            min_delay_secs,
            enabled,
        }
    }
}

// ============================================================================
// ANONYMITY SET HEALTH RESULT
// ============================================================================

/// Result of an anonymity set health check
#[derive(Debug, Clone)]
pub struct AnonymitySetHealth {
    /// Token mint that was checked
    pub token_mint: String,
    /// Number of recent transactions observed
    pub recent_tx_count: u64,
    /// Whether the anonymity set is healthy (sufficient activity)
    pub is_healthy: bool,
    /// Recommended delay in seconds (if unhealthy)
    pub recommended_delay_secs: Option<u64>,
    /// Timestamp of the check
    pub checked_at: DateTime<Utc>,
}

impl AnonymitySetHealth {
    /// Create a healthy result (no delay needed)
    pub fn healthy(token_mint: String, recent_tx_count: u64) -> Self {
        Self {
            token_mint,
            recent_tx_count,
            is_healthy: true,
            recommended_delay_secs: None,
            checked_at: Utc::now(),
        }
    }

    /// Create an unhealthy result with recommended delay
    pub fn unhealthy(token_mint: String, recent_tx_count: u64, delay_secs: u64) -> Self {
        Self {
            token_mint,
            recent_tx_count,
            is_healthy: false,
            recommended_delay_secs: Some(delay_secs),
            checked_at: Utc::now(),
        }
    }

    /// Skip the check result (e.g., API unavailable)
    /// Assumes healthy to prioritize liveness
    pub fn skipped(token_mint: String) -> Self {
        Self {
            token_mint,
            recent_tx_count: 0,
            is_healthy: true, // Assume healthy to prioritize liveness
            recommended_delay_secs: None,
            checked_at: Utc::now(),
        }
    }
}

// ============================================================================
// PRIVACY HEALTH CHECK SERVICE
// ============================================================================

/// Privacy Health Check Service
///
/// Checks the anonymity set health for confidential token transfers
/// and recommends delays when network activity is low.
pub struct PrivacyHealthCheckService {
    config: PrivacyHealthCheckConfig,
    token_api_client: Option<Arc<QuickNodeTokenApiClient>>,
}

impl PrivacyHealthCheckService {
    /// Create a new service with QuickNode Token API client
    pub fn new(
        config: PrivacyHealthCheckConfig,
        token_api_client: Option<Arc<QuickNodeTokenApiClient>>,
    ) -> Self {
        if config.enabled && token_api_client.is_some() {
            info!(
                threshold = config.min_tx_threshold,
                lookback_minutes = config.lookback_minutes,
                max_delay_secs = config.max_delay_secs,
                "🛡️ Privacy Health Check service initialized"
            );
        } else if config.enabled {
            warn!("Privacy Health Check enabled but no Token API client (will skip checks)");
        } else {
            debug!("Privacy Health Check service disabled");
        }

        Self {
            config,
            token_api_client,
        }
    }

    /// Create a disabled/passthrough service
    pub fn disabled() -> Self {
        Self {
            config: PrivacyHealthCheckConfig::disabled(),
            token_api_client: None,
        }
    }

    /// Check if the service is enabled and has API access
    pub fn is_operational(&self) -> bool {
        self.config.enabled && self.token_api_client.is_some()
    }

    /// Get the current configuration
    pub fn config(&self) -> &PrivacyHealthCheckConfig {
        &self.config
    }

    /// Check the anonymity set health for a token mint
    ///
    /// # Arguments
    /// * `token_mint` - The token mint address to check
    ///
    /// # Returns
    /// * `AnonymitySetHealth` - Health status with optional delay recommendation
    ///
    /// # Graceful Degradation
    /// If the Token API is unavailable or returns an error, the check is skipped
    /// and the transaction proceeds immediately (prioritizing liveness).
    pub async fn check_health(&self, token_mint: &str) -> AnonymitySetHealth {
        // Skip if disabled
        if !self.config.enabled {
            debug!(token_mint = %token_mint, "Privacy health check disabled, skipping");
            return AnonymitySetHealth::skipped(token_mint.to_string());
        }

        // Skip if no API client
        let client = match &self.token_api_client {
            Some(c) => c,
            None => {
                debug!(token_mint = %token_mint, "No Token API client, skipping health check");
                return AnonymitySetHealth::skipped(token_mint.to_string());
            }
        };

        // Query recent activity
        match client
            .get_recent_activity(token_mint, self.config.lookback_minutes)
            .await
        {
            Ok(activity) => {
                let recent_tx_count = activity.recent_tx_count;

                if recent_tx_count >= self.config.min_tx_threshold {
                    info!(
                        token_mint = %token_mint,
                        recent_tx_count = recent_tx_count,
                        threshold = self.config.min_tx_threshold,
                        "✅ Anonymity set HEALTHY - proceeding with submission"
                    );
                    AnonymitySetHealth::healthy(token_mint.to_string(), recent_tx_count)
                } else {
                    // Calculate randomized delay
                    let delay = self.calculate_delay(recent_tx_count);

                    warn!(
                        token_mint = %token_mint,
                        recent_tx_count = recent_tx_count,
                        threshold = self.config.min_tx_threshold,
                        delay_secs = delay,
                        "⚠️ Anonymity set UNHEALTHY - recommending delay"
                    );
                    AnonymitySetHealth::unhealthy(token_mint.to_string(), recent_tx_count, delay)
                }
            }
            Err(e) => {
                // Graceful degradation: log warning and proceed
                warn!(
                    token_mint = %token_mint,
                    error = %e,
                    "Privacy health check failed - skipping to preserve liveness"
                );
                AnonymitySetHealth::skipped(token_mint.to_string())
            }
        }
    }

    /// Calculate a randomized delay based on activity level
    fn calculate_delay(&self, recent_tx_count: u64) -> u64 {
        let mut rng = rand::thread_rng();

        // Lower activity = longer delay (inverse relationship)
        let activity_factor = if self.config.min_tx_threshold > 0 {
            1.0 - (recent_tx_count as f64 / self.config.min_tx_threshold as f64)
        } else {
            1.0
        };

        let base_delay = self.config.min_delay_secs as f64
            + (activity_factor * (self.config.max_delay_secs - self.config.min_delay_secs) as f64);

        // Add randomization (±30%)
        let jitter = rng.gen_range(0.7..1.3);
        let delay = (base_delay * jitter) as u64;

        delay.clamp(self.config.min_delay_secs, self.config.max_delay_secs)
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_default() {
        let config = PrivacyHealthCheckConfig::default();
        assert_eq!(config.min_tx_threshold, 5);
        assert_eq!(config.lookback_minutes, 10);
        assert_eq!(config.max_delay_secs, 120);
        assert_eq!(config.min_delay_secs, 10);
        assert!(config.enabled);
    }

    #[test]
    fn test_config_disabled() {
        let config = PrivacyHealthCheckConfig::disabled();
        assert!(!config.enabled);
    }

    #[test]
    fn test_health_result_healthy() {
        let health = AnonymitySetHealth::healthy("token123".to_string(), 10);
        assert!(health.is_healthy);
        assert!(health.recommended_delay_secs.is_none());
        assert_eq!(health.token_mint, "token123");
        assert_eq!(health.recent_tx_count, 10);
    }

    #[test]
    fn test_health_result_unhealthy() {
        let health = AnonymitySetHealth::unhealthy("token123".to_string(), 2, 60);
        assert!(!health.is_healthy);
        assert_eq!(health.recommended_delay_secs, Some(60));
        assert_eq!(health.recent_tx_count, 2);
    }

    #[test]
    fn test_health_result_skipped() {
        let health = AnonymitySetHealth::skipped("token123".to_string());
        assert!(health.is_healthy); // Skipped = assume healthy for liveness
        assert!(health.recommended_delay_secs.is_none());
        assert_eq!(health.recent_tx_count, 0);
    }

    #[test]
    fn test_disabled_service() {
        let service = PrivacyHealthCheckService::disabled();
        assert!(!service.is_operational());
        assert!(!service.config().enabled);
    }

    #[test]
    fn test_service_without_client() {
        let config = PrivacyHealthCheckConfig::default();
        let service = PrivacyHealthCheckService::new(config, None);
        assert!(!service.is_operational());
    }

    #[tokio::test]
    async fn test_check_health_disabled() {
        let service = PrivacyHealthCheckService::disabled();
        let health = service.check_health("some_mint").await;
        assert!(health.is_healthy);
        assert_eq!(health.token_mint, "some_mint");
    }

    #[tokio::test]
    async fn test_check_health_no_client() {
        let config = PrivacyHealthCheckConfig::default();
        let service = PrivacyHealthCheckService::new(config, None);
        let health = service.check_health("some_mint").await;
        assert!(health.is_healthy); // Skipped
    }

    #[test]
    fn test_calculate_delay_low_activity() {
        let config = PrivacyHealthCheckConfig {
            min_tx_threshold: 10,
            min_delay_secs: 10,
            max_delay_secs: 100,
            ..Default::default()
        };
        let service = PrivacyHealthCheckService::new(config, None);

        // With 0 activity, delay should be close to max
        let delay = service.calculate_delay(0);
        assert!(delay >= 10);
        assert!(delay <= 100);
    }

    #[test]
    fn test_calculate_delay_high_activity() {
        let config = PrivacyHealthCheckConfig {
            min_tx_threshold: 10,
            min_delay_secs: 10,
            max_delay_secs: 100,
            ..Default::default()
        };
        let service = PrivacyHealthCheckService::new(config, None);

        // With activity at threshold, delay should be close to min
        let delay = service.calculate_delay(9);
        assert!(delay >= 10);
        assert!(delay <= 100);
    }
}

===== ./infra/privacy/mod.rs =====
//! Privacy analytics and protection features.
//!
//! This module provides privacy-enhancing services for confidential transfers:
//! - Anonymity set health checks (assess network activity before submission)
//! - Smart delay mechanisms for timing attack mitigation
//!
//! # Ghost Mode Integration
//! Works alongside the QuickNode Ghost Mode (Jito bundles) to provide
//! comprehensive privacy protection for confidential transfers.

pub mod health_check;

pub use health_check::{AnonymitySetHealth, PrivacyHealthCheckConfig, PrivacyHealthCheckService};

===== ./lib.rs =====
//! Solana Compliance Relayer
//!
//! A production-ready Rust template demonstrating testable architecture through
//! trait-based abstraction and dependency injection.
//!
//! # Features
//!
//! - Clean Architecture with layered design
//! - Trait-based dependency injection for testability
//! - PostgreSQL with SQLx migrations
//! - Solana blockchain integration
//! - OpenAPI documentation with Swagger UI
//! - Rate limiting
//! - Graceful degradation with retry queues
//!
//! # Architecture
//!
//! ```text
//! ┌─────────────────────────────────────────┐
//! │              API Layer                  │
//! │   HTTP handlers, routing, validation    │
//! ├─────────────────────────────────────────┤
//! │           Application Layer             │
//! │    Business logic, orchestration        │
//! ├─────────────────────────────────────────┤
//! │             Domain Layer                │
//! │     Traits, types, errors (pure Rust)   │
//! ├─────────────────────────────────────────┤
//! │          Infrastructure Layer           │
//! │   Database, blockchain, external APIs   │
//! └─────────────────────────────────────────┘
//! ```

pub mod api;
pub mod app;
pub mod domain;
pub mod infra;

#[cfg(any(test, feature = "test-utils"))]
pub mod test_utils;

===== ./main.rs =====
//! Application entry point.

use std::env;
use std::sync::Arc;

use anyhow::{Context, Result};
use dotenvy::dotenv;
use ed25519_dalek::SigningKey;
use secrecy::SecretString;
use tokio::signal;
use tracing::{info, warn};
use tracing_subscriber::{EnvFilter, layer::SubscriberExt, util::SubscriberInitExt};

use solana_compliance_relayer::api::{
    RateLimitConfig, create_router, create_router_with_rate_limit,
};
use solana_compliance_relayer::app::{
    AppState, WorkerConfig, spawn_worker, spawn_worker_with_privacy,
};
use solana_compliance_relayer::infra::RpcBlockchainClient;
use solana_compliance_relayer::infra::blockchain::{QuickNodeTokenApiClient, RpcProviderType};
use solana_compliance_relayer::infra::{
    PostgresClient, PostgresConfig, PrivacyHealthCheckConfig, PrivacyHealthCheckService,
    signing_key_from_base58,
};

/// Application configuration
struct Config {
    database_url: String,
    blockchain_rpc_url: String,
    signing_key: SigningKey,
    host: String,
    port: u16,
    enable_rate_limiting: bool,
    rate_limit_config: RateLimitConfig,
    enable_background_worker: bool,
    worker_config: WorkerConfig,
    /// Range Protocol API key (optional - uses mock mode if not set)
    range_api_key: Option<String>,
    /// Range Protocol API base URL (optional - uses default if not set)
    range_api_url: Option<String>,
    /// Helius webhook secret for authentication (optional)
    helius_webhook_secret: Option<String>,
    /// Enable privacy health checks for confidential transfers
    enable_privacy_checks: bool,
}

impl Config {
    fn from_env() -> Result<Self> {
        let database_url = env::var("DATABASE_URL").context("DATABASE_URL not set")?;
        let blockchain_rpc_url = env::var("SOLANA_RPC_URL")
            .unwrap_or_else(|_| "https://api.devnet.solana.com".to_string());
        let signing_key = Self::load_signing_key()?;
        let host = env::var("HOST").unwrap_or_else(|_| "0.0.0.0".to_string());
        let port = env::var("PORT")
            .ok()
            .and_then(|p| p.parse().ok())
            .unwrap_or(3000);
        let enable_rate_limiting = env::var("ENABLE_RATE_LIMITING")
            .map(|v| v == "true" || v == "1")
            .unwrap_or(false);
        let enable_background_worker = env::var("ENABLE_BACKGROUND_WORKER")
            .map(|v| v == "true" || v == "1")
            .unwrap_or(true);

        // Range Protocol configuration (optional)
        let range_api_key = env::var("RANGE_API_KEY").ok().filter(|k| !k.is_empty());
        let range_api_url = env::var("RANGE_API_URL").ok().filter(|u| !u.is_empty());

        // Helius webhook configuration (optional)
        let helius_webhook_secret = env::var("HELIUS_WEBHOOK_SECRET")
            .ok()
            .filter(|s| !s.is_empty());

        let rate_limit_config = RateLimitConfig::from_env();

        // Privacy health check configuration
        let enable_privacy_checks = env::var("ENABLE_PRIVACY_CHECKS")
            .map(|v| v == "true" || v == "1")
            .unwrap_or(true); // Enabled by default

        let worker_config = WorkerConfig {
            enabled: enable_background_worker,
            enable_privacy_checks,
            ..Default::default()
        };

        Ok(Self {
            database_url,
            blockchain_rpc_url,
            signing_key,
            host,
            port,
            enable_rate_limiting,
            rate_limit_config,
            enable_background_worker,
            worker_config,
            range_api_key,
            range_api_url,
            helius_webhook_secret,
            enable_privacy_checks,
        })
    }

    fn load_signing_key() -> Result<SigningKey> {
        let key_str = env::var("ISSUER_PRIVATE_KEY").map_err(|_| {
            anyhow::anyhow!(
                "ISSUER_PRIVATE_KEY environment variable is not set.\n\
                 This is a REQUIRED configuration for production.\n\
                 Please set ISSUER_PRIVATE_KEY to a valid Base58-encoded Solana private key."
            )
        })?;

        if key_str.is_empty() {
            anyhow::bail!(
                "ISSUER_PRIVATE_KEY environment variable is empty.\n\
                 Please provide a valid Base58-encoded Solana private key."
            );
        }

        if key_str == "YOUR_BASE58_ENCODED_PRIVATE_KEY_HERE" {
            anyhow::bail!(
                "ISSUER_PRIVATE_KEY is set to the default placeholder value.\n\
                 Please replace it with your actual Base58-encoded Solana private key.\n\
                 SECURITY WARNING: Never run in production without a valid key!"
            );
        }

        info!("Loading signing key from environment");
        let secret = SecretString::from(key_str);
        signing_key_from_base58(&secret).context("Failed to parse ISSUER_PRIVATE_KEY as Base58")
    }
}

fn init_tracing() {
    let env_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=debug,sqlx=warn"));

    tracing_subscriber::registry()
        .with(env_filter)
        .with(tracing_subscriber::fmt::layer())
        .init();
}

async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("Failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("Failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => info!("Received Ctrl+C"),
        _ = terminate => info!("Received SIGTERM"),
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    dotenv().ok();
    init_tracing();

    info!(
        "🏗️  Solana Compliance Relayer v{}",
        env!("CARGO_PKG_VERSION")
    );

    let config = Config::from_env()?;

    let public_key = bs58::encode(config.signing_key.verifying_key().as_bytes()).into_string();
    info!("🔑 Public key: {}", public_key);

    info!("📦 Initializing infrastructure...");

    // Initialize database
    let db_config = PostgresConfig::default();
    let postgres_client = PostgresClient::new(&config.database_url, db_config).await?;
    postgres_client.run_migrations().await?;
    info!("   ✓ Database connected and migrations applied");

    // Initialize blockchain client
    let blockchain_client =
        RpcBlockchainClient::with_defaults(&config.blockchain_rpc_url, config.signing_key)?;
    info!("   ✓ Blockchain client created");

    // Initialize compliance provider
    let compliance_provider = solana_compliance_relayer::infra::RangeComplianceProvider::new(
        config.range_api_key.clone(),
        config.range_api_url.clone(),
    );
    if config.range_api_key.is_some() {
        info!("   ✓ Compliance provider created (Range Protocol API)");
    } else {
        warn!("   ⚠ Compliance provider created (MOCK MODE - no RANGE_API_KEY)");
    }

    // Create application state
    let mut app_state = AppState::with_helius_secret(
        Arc::new(postgres_client),
        Arc::new(blockchain_client),
        Arc::new(compliance_provider),
        config.helius_webhook_secret.clone(),
    );

    if config.helius_webhook_secret.is_some() {
        info!("   ✓ Helius webhook secret configured");
    } else {
        info!("   ○ Helius webhook secret not configured (webhook auth disabled)");
    }

    // Initialize privacy health check service (QuickNode only)
    let privacy_service = if config.enable_privacy_checks {
        let provider_type = RpcProviderType::detect(&config.blockchain_rpc_url);

        if matches!(provider_type, RpcProviderType::QuickNode) {
            let token_api_client =
                Arc::new(QuickNodeTokenApiClient::new(&config.blockchain_rpc_url));
            let privacy_config = PrivacyHealthCheckConfig::from_env();
            let service = Arc::new(PrivacyHealthCheckService::new(
                privacy_config,
                Some(token_api_client),
            ));
            info!("   ✓ Privacy Health Check service initialized (QuickNode)");
            Some(service)
        } else {
            info!("   ○ Privacy Health Check disabled (requires QuickNode RPC)");
            None
        }
    } else {
        info!("   ○ Privacy Health Check disabled via config");
        None
    };

    // Add privacy service to app state if available
    if let Some(ref privacy_svc) = privacy_service {
        app_state = app_state.with_privacy_service(Arc::clone(privacy_svc));
    }

    let app_state = Arc::new(app_state);

    // Start background worker if enabled
    let worker_shutdown_tx = if config.enable_background_worker {
        let (_worker_handle, shutdown_tx) = if let Some(ref privacy_svc) = privacy_service {
            spawn_worker_with_privacy(
                Arc::clone(&app_state.service),
                config.worker_config.clone(),
                Arc::clone(privacy_svc),
            )
        } else {
            spawn_worker(Arc::clone(&app_state.service), config.worker_config.clone())
        };
        info!("   ✓ Background worker started");
        Some(shutdown_tx)
    } else {
        info!("   ○ Background worker disabled");
        None
    };

    // Create router
    let router = if config.enable_rate_limiting {
        info!("   ✓ Rate limiting enabled");
        create_router_with_rate_limit(app_state, config.rate_limit_config)
    } else {
        info!("   ○ Rate limiting disabled");
        create_router(app_state)
    };

    let addr = format!("{}:{}", config.host, config.port);
    let listener = tokio::net::TcpListener::bind(&addr).await?;

    info!("🚀 Server starting on http://{}", addr);
    info!("📖 Swagger UI available at http://{}/swagger-ui", addr);
    info!("📄 OpenAPI spec at http://{}/api-docs/openapi.json", addr);

    axum::serve(listener, router)
        .with_graceful_shutdown(shutdown_signal())
        .await?;

    // Signal worker to shutdown
    if let Some(tx) = worker_shutdown_tx {
        let _ = tx.send(true);
    }

    info!("Server shutdown complete");
    Ok(())
}

===== ./project_dump.txt =====

===== ./test_utils/mocks.rs =====
//! Mock implementations for testing.

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::{Arc, Mutex};
use uuid::Uuid;

use crate::domain::{
    AppError, BlockchainClient, BlockchainError, BlockchainStatus, ComplianceStatus,
    DatabaseClient, DatabaseError, PaginatedResponse, SubmitTransferRequest, TransferRequest,
};

/// Configuration for mock behavior
#[derive(Debug, Clone, Default)]
pub struct MockConfig {
    pub should_fail: bool,
    pub error_message: Option<String>,
}

impl MockConfig {
    #[must_use]
    pub fn success() -> Self {
        Self::default()
    }

    #[must_use]
    pub fn failure(message: impl Into<String>) -> Self {
        Self {
            should_fail: true,
            error_message: Some(message.into()),
        }
    }
}

/// Mock database client for testing
pub struct MockDatabaseClient {
    storage: Arc<Mutex<HashMap<String, TransferRequest>>>,
    config: MockConfig,
    is_healthy: AtomicBool,
}

impl MockDatabaseClient {
    #[must_use]
    pub fn new() -> Self {
        Self::with_config(MockConfig::success())
    }

    #[must_use]
    pub fn with_config(config: MockConfig) -> Self {
        Self {
            storage: Arc::new(Mutex::new(HashMap::new())),
            config,
            is_healthy: AtomicBool::new(true),
        }
    }

    #[must_use]
    pub fn failing(message: impl Into<String>) -> Self {
        Self::with_config(MockConfig::failure(message))
    }

    pub fn set_healthy(&self, healthy: bool) {
        self.is_healthy.store(healthy, Ordering::Relaxed);
    }

    /// Get all stored items (for testing)
    pub fn get_all_items(&self) -> Vec<TransferRequest> {
        self.storage.lock().unwrap().values().cloned().collect()
    }

    fn check_should_fail(&self) -> Result<(), AppError> {
        if self.config.should_fail {
            let msg = self
                .config
                .error_message
                .clone()
                .unwrap_or_else(|| "Mock error".to_string());
            return Err(AppError::Database(DatabaseError::Query(msg)));
        }
        Ok(())
    }
}

impl Default for MockDatabaseClient {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl DatabaseClient for MockDatabaseClient {
    async fn health_check(&self) -> Result<(), AppError> {
        if !self.is_healthy.load(Ordering::Relaxed) {
            return Err(AppError::Database(DatabaseError::Connection(
                "Unhealthy".to_string(),
            )));
        }
        self.check_should_fail()
    }

    async fn get_transfer_request(&self, id: &str) -> Result<Option<TransferRequest>, AppError> {
        self.check_should_fail()?;
        let storage = self.storage.lock().unwrap();
        Ok(storage.get(id).cloned())
    }

    async fn submit_transfer(
        &self,
        data: &SubmitTransferRequest,
    ) -> Result<TransferRequest, AppError> {
        self.check_should_fail()?;
        let id = Uuid::new_v4().to_string();
        let now = Utc::now();

        // Simulating compliance check (default to Pending or Mock logic)
        let compliance_status = ComplianceStatus::Pending; // Or Approved if we want to simulate auto-approve

        let request = TransferRequest {
            id: id.clone(),
            from_address: data.from_address.clone(),
            to_address: data.to_address.clone(),
            transfer_details: data.transfer_details.clone(),
            token_mint: data.token_mint.clone(),
            compliance_status,
            blockchain_status: BlockchainStatus::Pending,
            blockchain_signature: None,
            blockchain_retry_count: 0,
            blockchain_last_error: None,
            blockchain_next_retry_at: None,
            created_at: now,
            updated_at: now,
        };
        let mut storage = self.storage.lock().unwrap();
        storage.insert(id, request.clone());
        Ok(request)
    }

    async fn list_transfer_requests(
        &self,
        limit: i64,
        cursor: Option<&str>,
    ) -> Result<PaginatedResponse<TransferRequest>, AppError> {
        self.check_should_fail()?;
        let storage = self.storage.lock().unwrap();
        let mut items: Vec<TransferRequest> = storage.values().cloned().collect();
        items.sort_by(|a, b| b.created_at.cmp(&a.created_at));

        // Apply cursor
        let items = if let Some(cursor_id) = cursor {
            let pos = items.iter().position(|i| i.id == cursor_id);
            match pos {
                Some(p) => items.into_iter().skip(p + 1).collect(),
                None => {
                    return Err(AppError::Validation(
                        crate::domain::ValidationError::InvalidField {
                            field: "cursor".to_string(),
                            message: "Invalid cursor".to_string(),
                        },
                    ));
                }
            }
        } else {
            items
        };

        let limit = limit.clamp(1, 100) as usize;
        let has_more = items.len() > limit;
        let items: Vec<TransferRequest> = items.into_iter().take(limit).collect();
        let next_cursor = if has_more {
            items.last().map(|i| i.id.clone())
        } else {
            None
        };

        Ok(PaginatedResponse::new(items, next_cursor, has_more))
    }

    async fn update_blockchain_status(
        &self,
        id: &str,
        status: BlockchainStatus,
        signature: Option<&str>,
        error: Option<&str>,
        next_retry_at: Option<DateTime<Utc>>,
    ) -> Result<(), AppError> {
        self.check_should_fail()?;
        let mut storage = self.storage.lock().unwrap();
        if let Some(item) = storage.get_mut(id) {
            item.blockchain_status = status;
            if let Some(sig) = signature {
                item.blockchain_signature = Some(sig.to_string());
            }
            item.blockchain_last_error = error.map(|e| e.to_string());
            item.blockchain_next_retry_at = next_retry_at;
            item.updated_at = Utc::now();
        }
        Ok(())
    }

    async fn update_compliance_status(
        &self,
        id: &str,
        status: ComplianceStatus,
    ) -> Result<(), AppError> {
        self.check_should_fail()?;
        let mut storage = self.storage.lock().unwrap();
        if let Some(item) = storage.get_mut(id) {
            item.compliance_status = status;
            item.updated_at = Utc::now();
        }
        Ok(())
    }

    /// Mock atomic claim: returns items with Processing status (like the real implementation)
    async fn get_pending_blockchain_requests(
        &self,
        limit: i64,
    ) -> Result<Vec<TransferRequest>, AppError> {
        self.check_should_fail()?;
        let mut storage = self.storage.lock().unwrap();
        let now = Utc::now();

        // Find eligible items
        let eligible_ids: Vec<String> = storage
            .values()
            .filter(|i| {
                i.blockchain_status == BlockchainStatus::PendingSubmission
                    && i.compliance_status == ComplianceStatus::Approved
                    && i.blockchain_retry_count < 10
                    && i.blockchain_next_retry_at.map(|t| t <= now).unwrap_or(true)
            })
            .take(limit as usize)
            .map(|i| i.id.clone())
            .collect();

        // Atomically update status to Processing and return claimed items
        let mut claimed_items = Vec::new();
        for id in eligible_ids {
            if let Some(item) = storage.get_mut(&id) {
                item.blockchain_status = BlockchainStatus::Processing;
                item.updated_at = Utc::now();
                claimed_items.push(item.clone());
            }
        }

        claimed_items.sort_by(|a, b| a.created_at.cmp(&b.created_at));
        Ok(claimed_items)
    }

    async fn increment_retry_count(&self, id: &str) -> Result<i32, AppError> {
        self.check_should_fail()?;
        let mut storage = self.storage.lock().unwrap();
        if let Some(item) = storage.get_mut(id) {
            item.blockchain_retry_count += 1;
            item.updated_at = Utc::now();
            Ok(item.blockchain_retry_count)
        } else {
            Err(AppError::Database(DatabaseError::NotFound(id.to_string())))
        }
    }

    async fn get_transfer_by_signature(
        &self,
        signature: &str,
    ) -> Result<Option<TransferRequest>, AppError> {
        self.check_should_fail()?;
        let storage = self.storage.lock().unwrap();
        Ok(storage
            .values()
            .find(|req| req.blockchain_signature.as_deref() == Some(signature))
            .cloned())
    }
}

/// Mock blockchain client for testing
pub struct MockBlockchainClient {
    transactions: Arc<Mutex<Vec<String>>>,
    config: MockConfig,
    is_healthy: AtomicBool,
}

impl MockBlockchainClient {
    #[must_use]
    pub fn new() -> Self {
        Self::with_config(MockConfig::success())
    }

    #[must_use]
    pub fn with_config(config: MockConfig) -> Self {
        Self {
            transactions: Arc::new(Mutex::new(Vec::new())),
            config,
            is_healthy: AtomicBool::new(true),
        }
    }

    #[must_use]
    pub fn failing(message: impl Into<String>) -> Self {
        Self::with_config(MockConfig::failure(message))
    }

    pub fn set_healthy(&self, healthy: bool) {
        self.is_healthy.store(healthy, Ordering::Relaxed);
    }

    pub fn get_transactions(&self) -> Vec<String> {
        self.transactions.lock().unwrap().clone()
    }

    fn check_should_fail(&self) -> Result<(), AppError> {
        if self.config.should_fail {
            let msg = self
                .config
                .error_message
                .clone()
                .unwrap_or_else(|| "Mock error".to_string());
            return Err(AppError::Blockchain(BlockchainError::TransactionFailed(
                msg,
            )));
        }
        Ok(())
    }
}

impl Default for MockBlockchainClient {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl BlockchainClient for MockBlockchainClient {
    async fn health_check(&self) -> Result<(), AppError> {
        if !self.is_healthy.load(Ordering::Relaxed) {
            return Err(AppError::Blockchain(BlockchainError::Connection(
                "Unhealthy".to_string(),
            )));
        }
        self.check_should_fail()
    }

    async fn submit_transaction(&self, request: &TransferRequest) -> Result<String, AppError> {
        self.check_should_fail()?;
        // Mock signature generation (e.g., hash of ID)
        let signature = format!("sig_{}", request.id);
        let mut transactions = self.transactions.lock().unwrap();
        transactions.push(request.id.clone());
        Ok(signature)
    }

    async fn get_transaction_status(&self, _signature: &str) -> Result<bool, AppError> {
        self.check_should_fail()?;
        // For mock purposes, assume if it's in our list it's valid
        // But here we store request IDs, not signatures.
        // Let's simplified assumption: always true if not failing
        Ok(true)
    }

    async fn get_latest_blockhash(&self) -> Result<String, AppError> {
        self.check_should_fail()?;
        Ok("mock_blockhash_abc123".to_string())
    }

    async fn transfer_sol(
        &self,
        to_address: &str,
        amount_lamports: u64,
    ) -> Result<String, AppError> {
        self.check_should_fail()?;
        let signature = format!(
            "transfer_sig_{}_{}",
            &to_address[..8.min(to_address.len())],
            amount_lamports
        );
        let mut transactions = self.transactions.lock().unwrap();
        transactions.push(format!("transfer:{}:{}", to_address, amount_lamports));
        Ok(signature)
    }

    async fn transfer_token(
        &self,
        to_address: &str,
        token_mint: &str,
        amount: u64,
    ) -> Result<String, AppError> {
        self.check_should_fail()?;
        let mint_prefix = &token_mint[..8.min(token_mint.len())];
        let signature = format!("token_sig_{}_{}", mint_prefix, amount);
        let mut transactions = self.transactions.lock().unwrap();
        transactions.push(format!(
            "token_transfer:{}:{}:{}",
            to_address, token_mint, amount
        ));
        Ok(signature)
    }

    async fn transfer_confidential(
        &self,
        to_address: &str,
        token_mint: &str,
        new_decryptable_available_balance: &str,
        equality_proof: &str,
        ciphertext_validity_proof: &str,
        range_proof: &str,
    ) -> Result<String, AppError> {
        self.check_should_fail()?;
        let mint_prefix = &token_mint[..8.min(token_mint.len())];
        let signature = format!("confidential_sig_{}", mint_prefix);
        let mut transactions = self.transactions.lock().unwrap();
        transactions.push(format!(
            "confidential_transfer:{}:{}:balance={}:eq={}:val={}:range={}",
            to_address,
            token_mint,
            new_decryptable_available_balance.len(),
            equality_proof.len(),
            ciphertext_validity_proof.len(),
            range_proof.len()
        ));
        Ok(signature)
    }
}

/// Mock compliance provider for testing
pub struct MockComplianceProvider {
    config: MockConfig,
}

impl MockComplianceProvider {
    pub fn new() -> Self {
        Self {
            config: MockConfig::success(),
        }
    }

    pub fn failing(message: impl Into<String>) -> Self {
        Self {
            config: MockConfig::failure(message),
        }
    }
}

impl Default for MockComplianceProvider {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl crate::domain::ComplianceProvider for MockComplianceProvider {
    async fn check_compliance(
        &self,
        _request: &SubmitTransferRequest,
    ) -> Result<ComplianceStatus, AppError> {
        if self.config.should_fail {
            return Err(AppError::ExternalService(
                crate::domain::ExternalServiceError::HttpError(
                    self.config.error_message.clone().unwrap_or_default(),
                ),
            ));
        }
        // Default to approved for mocks unless we specifically want to test rejection logic
        // We can extend this mock later if needed for specific test cases
        Ok(ComplianceStatus::Approved)
    }
}

===== ./test_utils/mod.rs =====
//! Test utilities and mock implementations.

pub mod mocks;

pub use mocks::{MockBlockchainClient, MockComplianceProvider, MockConfig, MockDatabaseClient};
